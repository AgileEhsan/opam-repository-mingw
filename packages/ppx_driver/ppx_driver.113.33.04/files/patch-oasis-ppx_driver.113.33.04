--- ./myocamlbuild.ml
+++ ./myocamlbuild.ml
@@ -1,12 +1,19 @@
 (* OASIS_START *)
-(* DO NOT EDIT (digest: 82e66f1186ca73d9f3c511737a9988de) *)
+(* DO NOT EDIT (digest: f22df00a2a271e2d86659c3d13ed14dc) *)
 module OASISGettext = struct
 (* # 22 "src/oasis/OASISGettext.ml" *)
 
 
-  let ns_ str = str
-  let s_ str = str
-  let f_ (str: ('a, 'b, 'c, 'd) format4) = str
+  let ns_ str =
+    str
+
+
+  let s_ str =
+    str
+
+
+  let f_ (str: ('a, 'b, 'c, 'd) format4) =
+    str
 
 
   let fn_ fmt1 fmt2 n =
@@ -16,7 +23,10 @@
       fmt2^^""
 
 
-  let init = []
+  let init =
+    []
+
+
 end
 
 module OASISString = struct
@@ -177,171 +187,27 @@
     else
       s
 
-end
-
-module OASISUtils = struct
-(* # 22 "src/oasis/OASISUtils.ml" *)
-
-
-  open OASISGettext
-
-
-  module MapExt =
-  struct
-    module type S =
-    sig
-      include Map.S
-      val add_list: 'a t -> (key * 'a) list -> 'a t
-      val of_list: (key * 'a) list -> 'a t
-      val to_list: 'a t -> (key * 'a) list
-    end
-
-    module Make (Ord: Map.OrderedType) =
-    struct
-      include Map.Make(Ord)
-
-      let rec add_list t =
-        function
-          | (k, v) :: tl -> add_list (add k v t) tl
-          | [] -> t
-
-      let of_list lst = add_list empty lst
-
-      let to_list t = fold (fun k v acc -> (k, v) :: acc) t []
-    end
-  end
-
-
-  module MapString = MapExt.Make(String)
-
-
-  module SetExt  =
-  struct
-    module type S =
-    sig
-      include Set.S
-      val add_list: t -> elt list -> t
-      val of_list: elt list -> t
-      val to_list: t -> elt list
-    end
-
-    module Make (Ord: Set.OrderedType) =
-    struct
-      include Set.Make(Ord)
-
-      let rec add_list t =
-        function
-          | e :: tl -> add_list (add e t) tl
-          | [] -> t
-
-      let of_list lst = add_list empty lst
-
-      let to_list = elements
-    end
-  end
-
-
-  module SetString = SetExt.Make(String)
-
-
-  let compare_csl s1 s2 =
-    String.compare (OASISString.lowercase_ascii s1) (OASISString.lowercase_ascii s2)
-
-
-  module HashStringCsl =
-    Hashtbl.Make
-      (struct
-         type t = string
-         let equal s1 s2 = (compare_csl s1 s2) = 0
-         let hash s = Hashtbl.hash (OASISString.lowercase_ascii s)
-       end)
-
-  module SetStringCsl =
-    SetExt.Make
-      (struct
-         type t = string
-         let compare = compare_csl
-       end)
-
-
-  let varname_of_string ?(hyphen='_') s =
-    if String.length s = 0 then
-      begin
-        invalid_arg "varname_of_string"
-      end
-    else
-      begin
-        let buf =
-          OASISString.replace_chars
-            (fun c ->
-               if ('a' <= c && c <= 'z')
-                 ||
-                  ('A' <= c && c <= 'Z')
-                 ||
-                  ('0' <= c && c <= '9') then
-                 c
-               else
-                 hyphen)
-            s;
-        in
-        let buf =
-          (* Start with a _ if digit *)
-          if '0' <= s.[0] && s.[0] <= '9' then
-            "_"^buf
+  let exists f str =
+    let rec iter i =
+      if i < 0 then
+        false
+      else if f str.[i] then
+        true
           else
-            buf
-        in
-          OASISString.lowercase_ascii buf
-      end
-
-
-  let varname_concat ?(hyphen='_') p s =
-    let what = String.make 1 hyphen in
-    let p =
-      try
-        OASISString.strip_ends_with ~what p
-      with Not_found ->
-        p
+        iter (pred i)
     in
-    let s =
-      try
-        OASISString.strip_starts_with ~what s
-      with Not_found ->
-        s
-    in
-      p^what^s
-
-
-  let is_varname str =
-    str = varname_of_string str
-
+      iter (String.length str - 1)
 
-  let failwithf fmt = Printf.ksprintf failwith fmt
-
-
-  let rec file_location ?pos1 ?pos2 ?lexbuf () =
-      match pos1, pos2, lexbuf with
-      | Some p, None, _ | None, Some p, _ ->
-        file_location ~pos1:p ~pos2:p ?lexbuf ()
-      | Some p1, Some p2, _ ->
-        let open Lexing in
-        let fn, lineno = p1.pos_fname, p1.pos_lnum in
-        let c1 = p1.pos_cnum - p1.pos_bol in
-        let c2 = c1 + (p2.pos_cnum - p1.pos_cnum) in
-        Printf.sprintf (f_ "file %S, line %d, characters %d-%d")  fn lineno c1 c2
-      | _, _, Some lexbuf ->
-        file_location
-          ~pos1:(Lexing.lexeme_start_p lexbuf)
-          ~pos2:(Lexing.lexeme_end_p lexbuf)
-          ()
-      | None, None, None ->
-        s_ "<position undefined>"
+  let is_digit c =
+    '0' <= c && c <= '9'
 
+  let is_alpha c =
+    ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')
 
-  let failwithpf ?pos1 ?pos2 ?lexbuf fmt =
-    let loc = file_location ?pos1 ?pos2 ?lexbuf () in
-    Printf.ksprintf (fun s -> failwith (Printf.sprintf "%s: %s" loc s)) fmt
-
+  let is_whitespace =
+    function
+      | ' ' | '\r' | '\n' | '\t' -> true
+      |  _  -> false
 
 end
 
@@ -349,8 +215,10 @@
 (* # 22 "src/oasis/OASISExpr.ml" *)
 
 
+
+
+
   open OASISGettext
-  open OASISUtils
 
 
   type test = string
@@ -440,7 +311,7 @@
 end
 
 
-# 443 "myocamlbuild.ml"
+# 314 "myocamlbuild.ml"
 module BaseEnvLight = struct
 (* # 22 "src/base/BaseEnvLight.ml" *)
 
@@ -451,12 +322,24 @@
   type t = string MapString.t
 
 
-  let default_filename = Filename.concat (Sys.getcwd ()) "setup.data"
+  let default_filename =
+    Filename.concat
+      (Sys.getcwd ())
+      "setup.data"
 
 
-  let load ?(allow_empty=false) ?(filename=default_filename) ?stream () =
-    let line = ref 1 in
-    let lexer st =
+  let load ?(allow_empty=false) ?(filename=default_filename) () =
+    if Sys.file_exists filename then
+      begin
+        let chn =
+          open_in_bin filename
+        in
+        let st =
+          Stream.of_channel chn
+        in
+        let line =
+          ref 1
+        in
       let st_line =
         Stream.from
           (fun _ ->
@@ -466,32 +349,36 @@
                | c -> Some c
              with Stream.Failure -> None)
       in
+        let lexer =
       Genlex.make_lexer ["="] st_line
     in
-    let rec read_file lxr mp =
-      match Stream.npeek 3 lxr with
+        let rec read_file mp =
+          match Stream.npeek 3 lexer with
       | [Genlex.Ident nm; Genlex.Kwd "="; Genlex.String value] ->
-        Stream.junk lxr; Stream.junk lxr; Stream.junk lxr;
-        read_file lxr (MapString.add nm value mp)
-      | [] -> mp
+                Stream.junk lexer;
+                Stream.junk lexer;
+                Stream.junk lexer;
+                read_file (MapString.add nm value mp)
+            | [] ->
+                mp
       | _ ->
         failwith
-          (Printf.sprintf "Malformed data file '%s' line %d" filename !line)
+                  (Printf.sprintf
+                     "Malformed data file '%s' line %d"
+                     filename !line)
     in
-    match stream with
-    | Some st -> read_file (lexer st) MapString.empty
-    | None ->
-      if Sys.file_exists filename then begin
-        let chn = open_in_bin filename in
-        let st = Stream.of_channel chn in
-        try
-          let mp = read_file (lexer st) MapString.empty in
-          close_in chn; mp
-        with e ->
-          close_in chn; raise e
-      end else if allow_empty then begin
+        let mp =
+          read_file MapString.empty
+        in
+          close_in chn;
+          mp
+      end
+    else if allow_empty then
+      begin
         MapString.empty
-      end else begin
+      end
+    else
+      begin
         failwith
           (Printf.sprintf
              "Unable to load environment, the file '%s' doesn't exist."
@@ -498,8 +385,11 @@
              filename)
       end
 
+
   let rec var_expand str env =
-    let buff = Buffer.create ((String.length str) * 2) in
+    let buff =
+      Buffer.create ((String.length str) * 2)
+    in
     Buffer.add_substitute
       buff
       (fun var ->
@@ -515,39 +405,49 @@
     Buffer.contents buff
 
 
-  let var_get name env = var_expand (MapString.find name env) env
-  let var_choose lst env = OASISExpr.choose (fun nm -> var_get nm env) lst
+  let var_get name env =
+    var_expand (MapString.find name env) env
+
+
+  let var_choose lst env =
+    OASISExpr.choose
+      (fun nm -> var_get nm env)
+      lst
 end
 
 
-# 523 "myocamlbuild.ml"
+# 419 "myocamlbuild.ml"
 module MyOCamlbuildFindlib = struct
 (* # 22 "src/plugins/ocamlbuild/MyOCamlbuildFindlib.ml" *)
 
 
   (** OCamlbuild extension, copied from
-    * https://ocaml.org/learn/tutorials/ocamlbuild/Using_ocamlfind_with_ocamlbuild.html
+    * http://brion.inria.fr/gallium/index.php/Using_ocamlfind_with_ocamlbuild
     * by N. Pouillard and others
     *
-    * Updated on 2016-06-02
+    * Updated on 2009/02/28
     *
     * Modified by Sylvain Le Gall
   *)
   open Ocamlbuild_plugin
 
+  type conf =
+    { no_automatic_syntax: bool;
+    }
 
-  type conf = {no_automatic_syntax: bool}
-
-
-  let run_and_read = Ocamlbuild_pack.My_unix.run_and_read
+  (* these functions are not really officially exported *)
+  let run_and_read =
+    Ocamlbuild_pack.My_unix.run_and_read
 
 
-  let blank_sep_strings = Ocamlbuild_pack.Lexers.blank_sep_strings
+  let blank_sep_strings =
+    Ocamlbuild_pack.Lexers.blank_sep_strings
 
 
   let exec_from_conf exec =
     let exec =
-      let env = BaseEnvLight.load ~allow_empty:true () in
+      let env_filename = Pathname.basename BaseEnvLight.default_filename in
+      let env = BaseEnvLight.load ~filename:env_filename ~allow_empty:true () in
       try
         BaseEnvLight.var_get exec env
       with Not_found ->
@@ -597,7 +496,9 @@
     with Not_found -> s
 
   (* ocamlfind command *)
-  let ocamlfind x = S[Sh (exec_from_conf "ocamlfind"); x]
+  let ocamlfind x = S[Sh (
+    Ocamlbuild_pack.Shell.quote_filename_if_needed
+      (exec_from_conf "ocamlfind") ); x]
 
   (* This lists all supported packages. *)
   let find_packages () =
@@ -639,13 +540,11 @@
 
       | After_rules ->
 
-        (* Avoid warnings for unused tag *)
-        flag ["tests"] N;
-
         (* When one link an OCaml library/binary/package, one should use
          * -linkpkg *)
         flag ["ocaml"; "link"; "program"] & A"-linkpkg";
 
+          if not (conf.no_automatic_syntax) then begin
         (* For each ocamlfind package one inject the -package option when
          * compiling, computing dependencies, generating documentation and
          * linking. *)
@@ -658,9 +557,8 @@
               (* Heuristic to identify syntax extensions: whether they end in
                  ".syntax"; some might not.
               *)
-              if not (conf.no_automatic_syntax) &&
-                 (Filename.check_suffix pkg "syntax" ||
-                  List.mem pkg well_known_syntax) then
+                  if Filename.check_suffix pkg "syntax" ||
+                     List.mem pkg well_known_syntax then
                 (syn_args @ base_args, syn_args)
               else
                 (base_args, [])
@@ -678,6 +576,7 @@
             flag ["ocaml"; "infer_interface"; "package("^pkg^")"] & S pargs;
           end
           (find_packages ());
+          end;
 
         (* Like -package but for extensions syntax. Morover -syntax is useless
          * when linking. *)
@@ -701,12 +600,10 @@
         flag ["ocaml"; "pkg_threads"; "doc"] (S[A "-I"; A "+threads"]);
         flag ["ocaml"; "pkg_threads"; "link"] (S[A "-thread"]);
         flag ["ocaml"; "pkg_threads"; "infer_interface"] (S[A "-thread"]);
-        flag ["c"; "pkg_threads"; "compile"] (S[A "-thread"]);
         flag ["ocaml"; "package(threads)"; "compile"] (S[A "-thread"]);
         flag ["ocaml"; "package(threads)"; "doc"] (S[A "-I"; A "+threads"]);
         flag ["ocaml"; "package(threads)"; "link"] (S[A "-thread"]);
         flag ["ocaml"; "package(threads)"; "infer_interface"] (S[A "-thread"]);
-        flag ["c"; "package(threads)"; "compile"] (S[A "-thread"]);
 
       | _ ->
         ()
@@ -731,6 +631,9 @@
   type tag = string
 
 
+(* # 62 "src/plugins/ocamlbuild/MyOCamlbuildBase.ml" *)
+
+
   type t =
       {
         lib_ocaml: (name * dir list * string list) list;
@@ -743,10 +646,9 @@
       }
 
 
-(* # 110 "src/plugins/ocamlbuild/MyOCamlbuildBase.ml" *)
-
-
-  let env_filename = Pathname.basename BaseEnvLight.default_filename
+  let env_filename =
+    Pathname.basename
+      BaseEnvLight.default_filename
 
 
   let dispatch_combine lst =
@@ -765,7 +667,12 @@
 
 
   let dispatch t e =
-    let env = BaseEnvLight.load ~allow_empty:true () in
+    let env =
+      BaseEnvLight.load
+        ~filename:env_filename
+        ~allow_empty:true
+        ()
+    in
       match e with
         | Before_options ->
             let no_trailing_dot s =
@@ -829,7 +736,6 @@
                    flag ["link"; "library"; "ocaml"; "native"; tag_libstubs lib]
                      (S[A"-cclib"; A("-l"^(nm_libstubs lib))]);
 
-                   if bool_of_string (BaseEnvLight.var_get "native_dynlink" env) then
                      flag ["link"; "program"; "ocaml"; "byte"; tag_libstubs lib]
                          (S[A"-dllib"; A("dll"^(nm_libstubs lib))]);
 
@@ -881,7 +787,7 @@
 end
 
 
-# 884 "myocamlbuild.ml"
+# 790 "myocamlbuild.ml"
 open Ocamlbuild_plugin;;
 let package_default =
   {
@@ -902,7 +808,7 @@
 
 let dispatch_default = MyOCamlbuildBase.dispatch_default conf package_default;;
 
-# 906 "myocamlbuild.ml"
+# 812 "myocamlbuild.ml"
 (* OASIS_STOP *)
 # 3 "myocamlbuild.ml"
 
--- ./setup.ml
+++ ./setup.ml
@@ -1,7 +1,7 @@
 (* OASIS_START *)
-(* DO NOT EDIT (digest: dfc48e951c19533e9ceb89d507d05f8d) *)
+(* DO NOT EDIT (digest: 5a86dcbcb6392746e845b114919e4611) *)
 (*
-   Regenerated by OASIS v0.4.8
+   Regenerated by OASIS v0.4.6
    Visit http://oasis.forge.ocamlcore.org for more information and
    documentation about functions used in this file.
 *)
@@ -9,9 +9,16 @@
 (* # 22 "src/oasis/OASISGettext.ml" *)
 
 
-  let ns_ str = str
-  let s_ str = str
-  let f_ (str: ('a, 'b, 'c, 'd) format4) = str
+  let ns_ str =
+    str
+
+
+  let s_ str =
+    str
+
+
+  let f_ (str: ('a, 'b, 'c, 'd) format4) =
+    str
 
 
   let fn_ fmt1 fmt2 n =
@@ -21,7 +28,90 @@
       fmt2^^""
 
 
-  let init = []
+  let init =
+    []
+
+
+end
+
+module OASISContext = struct
+(* # 22 "src/oasis/OASISContext.ml" *)
+
+
+  open OASISGettext
+
+
+  type level =
+    [ `Debug
+    | `Info
+    | `Warning
+    | `Error]
+
+
+  type t =
+    {
+      (* TODO: replace this by a proplist. *)
+      quiet:                 bool;
+      info:                  bool;
+      debug:                 bool;
+      ignore_plugins:        bool;
+      ignore_unknown_fields: bool;
+      printf:                level -> string -> unit;
+    }
+
+
+  let printf lvl str =
+    let beg =
+      match lvl with
+        | `Error -> s_ "E: "
+        | `Warning -> s_ "W: "
+        | `Info  -> s_ "I: "
+        | `Debug -> s_ "D: "
+    in
+      prerr_endline (beg^str)
+
+
+  let default =
+    ref
+      {
+        quiet                 = false;
+        info                  = false;
+        debug                 = false;
+        ignore_plugins        = false;
+        ignore_unknown_fields = false;
+        printf                = printf;
+      }
+
+
+  let quiet =
+    {!default with quiet = true}
+
+
+  let fspecs () =
+    (* TODO: don't act on default. *)
+    let ignore_plugins = ref false in
+    ["-quiet",
+     Arg.Unit (fun () -> default := {!default with quiet = true}),
+     s_ " Run quietly";
+
+     "-info",
+     Arg.Unit (fun () -> default := {!default with info = true}),
+     s_ " Display information message";
+
+
+     "-debug",
+     Arg.Unit (fun () -> default := {!default with debug = true}),
+     s_ " Output debug message";
+
+     "-ignore-plugins",
+     Arg.Set ignore_plugins,
+     s_ " Ignore plugin's field.";
+
+     "-C",
+     (* TODO: remove this chdir. *)
+     Arg.String (fun str -> Sys.chdir str),
+     s_ "dir Change directory before running."],
+    fun () -> {!default with ignore_plugins = !ignore_plugins}
 end
 
 module OASISString = struct
@@ -182,6 +272,28 @@
     else
       s
 
+  let exists f str =
+    let rec iter i =
+      if i < 0 then
+        false
+      else if f str.[i] then
+        true
+      else
+        iter (pred i)
+    in
+      iter (String.length str - 1)
+
+  let is_digit c =
+    '0' <= c && c <= '9'
+   
+  let is_alpha c =
+    ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')
+
+  let is_whitespace =
+    function
+      | ' ' | '\r' | '\n' | '\t' -> true
+      |  _  -> false
+
 end
 
 module OASISUtils = struct
@@ -324,398 +436,6 @@
   let failwithf fmt = Printf.ksprintf failwith fmt
 
 
-  let rec file_location ?pos1 ?pos2 ?lexbuf () =
-      match pos1, pos2, lexbuf with
-      | Some p, None, _ | None, Some p, _ ->
-        file_location ~pos1:p ~pos2:p ?lexbuf ()
-      | Some p1, Some p2, _ ->
-        let open Lexing in
-        let fn, lineno = p1.pos_fname, p1.pos_lnum in
-        let c1 = p1.pos_cnum - p1.pos_bol in
-        let c2 = c1 + (p2.pos_cnum - p1.pos_cnum) in
-        Printf.sprintf (f_ "file %S, line %d, characters %d-%d")  fn lineno c1 c2
-      | _, _, Some lexbuf ->
-        file_location
-          ~pos1:(Lexing.lexeme_start_p lexbuf)
-          ~pos2:(Lexing.lexeme_end_p lexbuf)
-          ()
-      | None, None, None ->
-        s_ "<position undefined>"
-
-
-  let failwithpf ?pos1 ?pos2 ?lexbuf fmt =
-    let loc = file_location ?pos1 ?pos2 ?lexbuf () in
-    Printf.ksprintf (fun s -> failwith (Printf.sprintf "%s: %s" loc s)) fmt
-
-
-end
-
-module OASISUnixPath = struct
-(* # 22 "src/oasis/OASISUnixPath.ml" *)
-
-
-  type unix_filename = string
-  type unix_dirname = string
-
-
-  type host_filename = string
-  type host_dirname = string
-
-
-  let current_dir_name = "."
-
-
-  let parent_dir_name = ".."
-
-
-  let is_current_dir fn =
-    fn = current_dir_name || fn = ""
-
-
-  let concat f1 f2 =
-    if is_current_dir f1 then
-      f2
-    else
-      let f1' =
-        try OASISString.strip_ends_with ~what:"/" f1 with Not_found -> f1
-      in
-      f1'^"/"^f2
-
-
-  let make =
-    function
-      | hd :: tl ->
-        List.fold_left
-          (fun f p -> concat f p)
-          hd
-          tl
-      | [] ->
-        invalid_arg "OASISUnixPath.make"
-
-
-  let dirname f =
-    try
-      String.sub f 0 (String.rindex f '/')
-    with Not_found ->
-      current_dir_name
-
-
-  let basename f =
-    try
-      let pos_start =
-        (String.rindex f '/') + 1
-      in
-      String.sub f pos_start ((String.length f) - pos_start)
-    with Not_found ->
-      f
-
-
-  let chop_extension f =
-    try
-      let last_dot =
-        String.rindex f '.'
-      in
-      let sub =
-        String.sub f 0 last_dot
-      in
-      try
-        let last_slash =
-          String.rindex f '/'
-        in
-        if last_slash < last_dot then
-          sub
-        else
-          f
-      with Not_found ->
-        sub
-
-    with Not_found ->
-      f
-
-
-  let capitalize_file f =
-    let dir = dirname f in
-    let base = basename f in
-    concat dir (OASISString.capitalize_ascii base)
-
-
-  let uncapitalize_file f =
-    let dir = dirname f in
-    let base = basename f in
-    concat dir (OASISString.uncapitalize_ascii base)
-
-
-end
-
-module OASISHostPath = struct
-(* # 22 "src/oasis/OASISHostPath.ml" *)
-
-
-  open Filename
-  open OASISGettext
-
-
-  module Unix = OASISUnixPath
-
-
-  let make =
-    function
-      | [] ->
-        invalid_arg "OASISHostPath.make"
-      | hd :: tl ->
-        List.fold_left Filename.concat hd tl
-
-
-  let of_unix ufn =
-    match Sys.os_type with
-    | "Unix" | "Cygwin" -> ufn
-    | "Win32" ->
-      make
-        (List.map
-           (fun p ->
-              if p = Unix.current_dir_name then
-                current_dir_name
-              else if p = Unix.parent_dir_name then
-                parent_dir_name
-              else
-                p)
-           (OASISString.nsplit ufn '/'))
-    | os_type ->
-      OASISUtils.failwithf
-        (f_ "Don't know the path format of os_type %S when translating unix \
-             filename. %S")
-        os_type ufn
-
-
-end
-
-module OASISFileSystem = struct
-(* # 22 "src/oasis/OASISFileSystem.ml" *)
-
-  (** File System functions
-
-      @author Sylvain Le Gall
-  *)
-
-  type 'a filename = string
-
-  class type closer =
-    object
-      method close: unit
-    end
-
-  class type reader =
-    object
-      inherit closer
-      method input: Buffer.t -> int -> unit
-    end
-
-  class type writer =
-    object
-      inherit closer
-      method output: Buffer.t -> unit
-    end
-
-  class type ['a] fs =
-    object
-      method string_of_filename: 'a filename -> string
-      method open_out: ?mode:(open_flag list) -> ?perm:int -> 'a filename -> writer
-      method open_in: ?mode:(open_flag list) -> ?perm:int -> 'a filename -> reader
-      method file_exists: 'a filename -> bool
-      method remove: 'a filename -> unit
-    end
-
-
-  module Mode =
-  struct
-    let default_in = [Open_rdonly]
-    let default_out = [Open_wronly; Open_creat; Open_trunc]
-
-    let text_in = Open_text :: default_in
-    let text_out = Open_text :: default_out
-
-    let binary_in = Open_binary :: default_in
-    let binary_out = Open_binary :: default_out
-  end
-
-  let std_length = 4096 (* Standard buffer/read length. *)
-  let binary_out = Mode.binary_out
-  let binary_in = Mode.binary_in
-
-  let of_unix_filename ufn = (ufn: 'a filename)
-  let to_unix_filename fn = (fn: string)
-
-
-  let defer_close o f =
-    try
-      let r = f o in o#close; r
-    with e ->
-      o#close; raise e
-
-
-  let stream_of_reader rdr =
-    let buf = Buffer.create std_length in
-    let pos = ref 0 in
-    let eof = ref false in
-    let rec next idx =
-      let bpos = idx - !pos in
-      if !eof then begin
-        None
-      end else if bpos < Buffer.length buf then begin
-        Some (Buffer.nth buf bpos)
-      end else begin
-        pos := !pos + Buffer.length buf;
-        Buffer.clear buf;
-        begin
-          try
-            rdr#input buf std_length;
-          with End_of_file ->
-            if Buffer.length buf = 0 then
-              eof := true
-        end;
-        next idx
-      end
-    in
-    Stream.from next
-
-
-  let read_all buf rdr =
-    try
-      while true do
-        rdr#input buf std_length
-      done
-    with End_of_file ->
-      ()
-
-  class ['a] host_fs rootdir : ['a] fs =
-    object (self)
-      method private host_filename fn = Filename.concat rootdir fn
-      method string_of_filename = self#host_filename
-
-      method open_out ?(mode=Mode.text_out)  ?(perm=0o666) fn =
-        let chn = open_out_gen mode perm (self#host_filename fn) in
-        object
-          method close = close_out chn
-          method output buf = Buffer.output_buffer chn buf
-        end
-
-      method open_in ?(mode=Mode.text_in) ?(perm=0o666) fn =
-        (* TODO: use Buffer.add_channel when minimal version of OCaml will
-         * be >= 4.03.0 (previous version was discarding last chars).
-         *)
-        let chn = open_in_gen mode perm (self#host_filename fn) in
-        let strm = Stream.of_channel chn in
-        object
-          method close = close_in chn
-          method input buf len =
-            let read = ref 0 in
-            try
-              for _i = 0 to len do
-                Buffer.add_char buf (Stream.next strm);
-                incr read
-              done
-            with Stream.Failure ->
-              if !read = 0 then
-                raise End_of_file
-        end
-
-      method file_exists fn = Sys.file_exists (self#host_filename fn)
-      method remove fn = Sys.remove (self#host_filename fn)
-    end
-
-end
-
-module OASISContext = struct
-(* # 22 "src/oasis/OASISContext.ml" *)
-
-
-  open OASISGettext
-
-
-  type level =
-    [ `Debug
-    | `Info
-    | `Warning
-    | `Error]
-
-
-  type source
-  type source_filename = source OASISFileSystem.filename
-
-
-  let in_srcdir ufn = OASISFileSystem.of_unix_filename ufn
-
-
-  type t =
-    {
-      (* TODO: replace this by a proplist. *)
-      quiet:                 bool;
-      info:                  bool;
-      debug:                 bool;
-      ignore_plugins:        bool;
-      ignore_unknown_fields: bool;
-      printf:                level -> string -> unit;
-      srcfs:                 source OASISFileSystem.fs;
-      load_oasis_plugin:     string -> bool;
-    }
-
-
-  let printf lvl str =
-    let beg =
-      match lvl with
-        | `Error -> s_ "E: "
-        | `Warning -> s_ "W: "
-        | `Info  -> s_ "I: "
-        | `Debug -> s_ "D: "
-    in
-    prerr_endline (beg^str)
-
-
-  let default =
-    ref
-      {
-        quiet                 = false;
-        info                  = false;
-        debug                 = false;
-        ignore_plugins        = false;
-        ignore_unknown_fields = false;
-        printf                = printf;
-        srcfs                 = new OASISFileSystem.host_fs(Sys.getcwd ());
-        load_oasis_plugin     = (fun _ -> false);
-      }
-
-
-  let quiet =
-    {!default with quiet = true}
-
-
-  let fspecs () =
-    (* TODO: don't act on default. *)
-    let ignore_plugins = ref false in
-    ["-quiet",
-     Arg.Unit (fun () -> default := {!default with quiet = true}),
-     s_ " Run quietly";
-
-     "-info",
-     Arg.Unit (fun () -> default := {!default with info = true}),
-     s_ " Display information message";
-
-
-     "-debug",
-     Arg.Unit (fun () -> default := {!default with debug = true}),
-     s_ " Output debug message";
-
-     "-ignore-plugins",
-     Arg.Set ignore_plugins,
-     s_ " Ignore plugin's field.";
-
-     "-C",
-     Arg.String
-       (fun str ->
-          Sys.chdir str;
-          default := {!default with srcfs = new OASISFileSystem.host_fs str}),
-     s_ "dir Change directory before running (affects setup.{data,log})."],
-    fun () -> {!default with ignore_plugins = !ignore_plugins}
 end
 
 module PropList = struct
@@ -765,7 +485,7 @@
       Hashtbl.clear t
 
 
-(* # 77 "src/oasis/PropList.ml" *)
+(* # 78 "src/oasis/PropList.ml" *)
   end
 
 
@@ -1054,6 +774,12 @@
   open OASISGettext
 
 
+
+
+
+  type s = string
+
+
   type t = string
 
 
@@ -1067,10 +793,18 @@
     | VAnd of comparator * comparator
 
 
+
   (* Range of allowed characters *)
-  let is_digit c = '0' <= c && c <= '9'
-  let is_alpha c = ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')
-  let is_special = function | '.' | '+' | '-' | '~' -> true | _ -> false
+  let is_digit = OASISString.is_digit
+
+
+  let is_alpha = OASISString.is_alpha
+
+
+  let is_special =
+    function
+      | '.' | '+' | '-' | '~' -> true
+      | _ -> false
 
 
   let rec version_compare v1 v2 =
@@ -1148,7 +882,8 @@
           | n ->
             n
       end
-    else begin
+    else
+      begin
       0
     end
 
@@ -1159,6 +894,10 @@
   let string_of_version t = t
 
 
+  let version_compare_string s1 s2 =
+    version_compare (version_of_string s1) (version_of_string s2)
+
+
   let chop t =
     try
       let pos =
@@ -1219,6 +958,18 @@
         (varname_of_comparator c1)^"_and_"^(varname_of_comparator c2)
 
 
+  let rec comparator_ge v' =
+    let cmp v = version_compare v v' >= 0 in
+    function
+      | VEqual v
+      | VGreaterEqual v
+      | VGreater v -> cmp v
+      | VLesserEqual _
+      | VLesser _ -> false
+      | VOr (c1, c2) -> comparator_ge v' c1 || comparator_ge v' c2
+      | VAnd (c1, c2) -> comparator_ge v' c1 && comparator_ge v' c2
+
+
 end
 
 module OASISLicense = struct
@@ -1265,8 +1024,10 @@
 (* # 22 "src/oasis/OASISExpr.ml" *)
 
 
+
+
+
   open OASISGettext
-  open OASISUtils
 
 
   type test = string
@@ -1367,148 +1134,20 @@
 
 end
 
-module OASISSourcePatterns = struct
-(* # 22 "src/oasis/OASISSourcePatterns.ml" *)
-
-  open OASISUtils
-  open OASISGettext
-
-  module Templater =
-  struct
-    (* TODO: use this module in BaseEnv.var_expand and BaseFileAB, at least. *)
-    type t =
-      {
-        atoms: atom list;
-        origin: string
-      }
-    and atom =
-      | Text of string
-      | Expr of expr
-    and expr =
-      | Ident of string
-      | String of string
-      | Call of string * expr
-
-
-    type env =
-      {
-        variables: string MapString.t;
-        functions: (string -> string) MapString.t;
-      }
-
-
-    let eval env t =
-      let rec eval_expr env =
-        function
-        | String str -> str
-        | Ident nm ->
-          begin
-            try
-              MapString.find nm env.variables
-            with Not_found ->
-              (* TODO: add error location within the string. *)
-              failwithf
-                (f_ "Unable to find variable %S in source pattern %S")
-                nm t.origin
-          end
-
-        | Call (fn, expr) ->
-          begin
-            try
-              (MapString.find fn env.functions) (eval_expr env expr)
-            with Not_found ->
-              (* TODO: add error location within the string. *)
-              failwithf
-                (f_ "Unable to find function %S in source pattern %S")
-                fn t.origin
-          end
-      in
-      String.concat ""
-        (List.map
-           (function
-             | Text str -> str
-             | Expr expr -> eval_expr env expr)
-           t.atoms)
-
-
-    let parse env s =
-      let lxr = Genlex.make_lexer [] in
-      let parse_expr s =
-        let st = lxr (Stream.of_string s) in
-        match Stream.npeek 3 st with
-        | [Genlex.Ident fn; Genlex.Ident nm] -> Call(fn, Ident nm)
-        | [Genlex.Ident fn; Genlex.String str] -> Call(fn, String str)
-        | [Genlex.String str] -> String str
-        | [Genlex.Ident nm] -> Ident nm
-        (* TODO: add error location within the string. *)
-        | _ -> failwithf (f_ "Unable to parse expression %S") s
-      in
-      let parse s =
-        let lst_exprs = ref [] in
-        let ss =
-          let buff = Buffer.create (String.length s) in
-          Buffer.add_substitute
-            buff
-            (fun s -> lst_exprs := (parse_expr s) :: !lst_exprs; "\000")
-            s;
-          Buffer.contents buff
-        in
-        let rec join =
-          function
-          | hd1 :: tl1, hd2 :: tl2 -> Text hd1 :: Expr hd2 :: join (tl1, tl2)
-          | [], tl -> List.map (fun e -> Expr e) tl
-          | tl, [] -> List.map (fun e -> Text e) tl
-        in
-        join (OASISString.nsplit ss '\000', List.rev (!lst_exprs))
-      in
-      let t = {atoms = parse s; origin = s} in
-      (* We rely on a simple evaluation for checking variables/functions.
-         It works because there is no if/loop statement.
-      *)
-      let _s : string = eval env t in
-      t
-
-(* # 144 "src/oasis/OASISSourcePatterns.ml" *)
-  end
-
-
-  type t = Templater.t
-
-
-  let env ~modul () =
-    {
-      Templater.
-      variables = MapString.of_list ["module", modul];
-      functions = MapString.of_list
-          [
-            "capitalize_file", OASISUnixPath.capitalize_file;
-            "uncapitalize_file", OASISUnixPath.uncapitalize_file;
-          ];
-    }
-
-  let all_possible_files lst ~path ~modul =
-    let eval = Templater.eval (env ~modul ()) in
-    List.fold_left
-      (fun acc pat -> OASISUnixPath.concat path (eval pat) :: acc)
-      [] lst
-
-
-  let to_string t = t.Templater.origin
+module OASISTypes = struct
+(* # 22 "src/oasis/OASISTypes.ml" *)
 
 
-end
 
-module OASISTypes = struct
-(* # 22 "src/oasis/OASISTypes.ml" *)
 
 
   type name          = string
   type package_name  = string
   type url           = string
   type unix_dirname  = string
-  type unix_filename = string (* TODO: replace everywhere. *)
-  type host_dirname  = string (* TODO: replace everywhere. *)
-  type host_filename = string (* TODO: replace everywhere. *)
+  type unix_filename = string
+  type host_dirname  = string
+  type host_filename = string
   type prog          = string
   type arg           = string
   type args          = string list
@@ -1581,6 +1224,9 @@
   type plugin_data = (all_plugin * plugin_data_purpose * (unit -> unit)) list
 
 
+(* # 115 "src/oasis/OASISTypes.ml" *)
+
+
   type 'a conditional = 'a OASISExpr.choices
 
 
@@ -1607,11 +1255,8 @@
       bs_compiled_object:         compiled_object;
       bs_build_depends:           dependency list;
       bs_build_tools:             tool list;
-      bs_interface_patterns:      OASISSourcePatterns.t list;
-      bs_implementation_patterns: OASISSourcePatterns.t list;
       bs_c_sources:               unix_filename list;
       bs_data_files:              (unix_filename * unix_filename option) list;
-      bs_findlib_extra_files:     unix_filename list;
       bs_ccopt:                   args conditional;
       bs_cclib:                   args conditional;
       bs_dlllib:                  args conditional;
@@ -1628,7 +1274,6 @@
       lib_internal_modules:   string list;
       lib_findlib_parent:     findlib_name option;
       lib_findlib_name:       findlib_name option;
-      lib_findlib_directory:  unix_dirname option;
       lib_findlib_containers: findlib_name list;
     }
 
@@ -1637,7 +1282,6 @@
     {
       obj_modules:            string list;
       obj_findlib_fullname:   findlib_name list option;
-      obj_findlib_directory:  unix_dirname option;
     }
 
 
@@ -1679,11 +1323,11 @@
 
 
   type doc_format =
-    | HTML of unix_filename (* TODO: source filename. *)
+    | HTML of unix_filename
     | DocText
     | PDF
     | PostScript
-    | Info of unix_filename (* TODO: source filename. *)
+    | Info of unix_filename
     | DVI
     | OtherDoc
 
@@ -1694,12 +1339,11 @@
       doc_custom:      custom;
       doc_build:       bool conditional;
       doc_install:     bool conditional;
-      doc_install_dir: unix_filename; (* TODO: dest filename ?. *)
+        doc_install_dir: unix_filename;
       doc_title:       string;
       doc_authors:     string list;
       doc_abstract:    string option;
       doc_format:      doc_format;
-      (* TODO: src filename. *)
       doc_data_files:  (unix_filename * unix_filename option) list;
       doc_build_tools: tool list;
     }
@@ -1729,15 +1374,13 @@
       name:                   package_name;
       version:                OASISVersion.t;
       license:                OASISLicense.t;
-      license_file:           unix_filename option; (* TODO: source filename. *)
+        license_file:           unix_filename option;
       copyrights:             string list;
       maintainers:            string list;
       authors:                string list;
       homepage:               url option;
-      bugreports:             url option;
       synopsis:               string;
       description:            OASISText.t option;
-      tags:                   string list;
       categories:             url list;
 
       conf_type:              [`Configure] plugin;
@@ -1753,10 +1396,10 @@
       clean_custom:           custom;
       distclean_custom:       custom;
 
-      files_ab:               unix_filename list; (* TODO: source filename. *)
+        files_ab:               unix_filename list;
       sections:               section list;
       plugins:                [`Extra] plugin list;
-      disable_oasis_section:  unix_filename list; (* TODO: source filename. *)
+        disable_oasis_section:  unix_filename list;
       schema_data:            PropList.Data.t;
       plugin_data:            plugin_data;
     }
@@ -1817,7 +1460,7 @@
       Printf.sprintf
         "oasis_version: %s; alpha_features: %s; beta_features: %s; \
          plugins_version: %s"
-        (OASISVersion.string_of_version (t:t).oasis_version)
+        (OASISVersion.string_of_version t.oasis_version)
         (String.concat ", " t.alpha_features)
         (String.concat ", " t.beta_features)
         (String.concat ", "
@@ -1873,7 +1516,7 @@
   let to_string t =
     Printf.sprintf
       "feature: %s; plugin: %s; publication: %s"
-      (t:t).name
+      t.name
       (match t.plugin with
        | None -> "<none>"
        | Some (_, nm, _) -> nm)
@@ -1885,9 +1528,9 @@
     let no_message = "no message" in
 
     let check_feature features stage =
-      let has_feature = List.mem (t:t).name features in
+      let has_feature = List.mem t.name features in
       if not has_feature then
-        match (origin:origin) with
+        match origin with
         | Field (fld, where) ->
           Some
             (Printf.sprintf
@@ -1912,7 +1555,11 @@
           version (OASISVersion.VGreaterEqual min_version)
       in
       Printf.ksprintf
-        (fun str -> if version_is_good then None else Some str)
+          (fun str ->
+             if version_is_good then
+               None
+             else
+               Some str)
         fmt
     in
 
@@ -2032,7 +1679,7 @@
   let data_test t data =
     match data_check t data NoOrigin with
     | None -> true
-    | Some _ -> false
+      | Some str -> false
 
 
   let package_test t pkg =
@@ -2082,14 +1729,14 @@
     create "flag_docs"
       (since_version "0.3")
       (fun () ->
-         s_ "Make building docs require '-docs' flag at configure.")
+         s_ "Building docs require '-docs' flag at configure.")
 
 
   let flag_tests =
     create "flag_tests"
       (since_version "0.3")
       (fun () ->
-         s_ "Make running tests require '-tests' flag at configure.")
+         s_ "Running tests require '-tests' flag at configure.")
 
 
   let pack =
@@ -2114,12 +1761,12 @@
   let compiled_setup_ml =
     create "compiled_setup_ml" alpha
       (fun () ->
-         s_ "Compile the setup.ml and speed-up actions done with it.")
+         s_ "It compiles the setup.ml and speed-up actions done with it.")
 
   let disable_oasis_section =
     create "disable_oasis_section" alpha
       (fun () ->
-         s_ "Allow the OASIS section comments and digests to be omitted in \
+        s_ "Allows the OASIS section comments and digest to be omitted in \
              generated files.")
 
   let no_automatic_syntax =
@@ -2128,22 +1775,263 @@
          s_ "Disable the automatic inclusion of -syntax camlp4o for packages \
              that matches the internal heuristic (if a dependency ends with \
              a .syntax or is a well known syntax).")
+end
 
-  let findlib_directory =
-    create "findlib_directory" beta
-      (fun () ->
-         s_ "Allow to install findlib libraries in sub-directories of the target \
-            findlib directory.")
+module OASISUnixPath = struct
+(* # 22 "src/oasis/OASISUnixPath.ml" *)
+
+
+  type unix_filename = string
+  type unix_dirname = string
+
+
+  type host_filename = string
+  type host_dirname = string
+
+
+  let current_dir_name = "."
+
+
+  let parent_dir_name = ".."
+
+
+  let is_current_dir fn =
+    fn = current_dir_name || fn = ""
+
+
+  let concat f1 f2 =
+    if is_current_dir f1 then
+      f2
+    else
+      let f1' =
+        try OASISString.strip_ends_with ~what:"/" f1 with Not_found -> f1
+      in
+        f1'^"/"^f2
+
+
+  let make =
+    function
+      | hd :: tl ->
+          List.fold_left
+            (fun f p -> concat f p)
+            hd
+            tl
+      | [] ->
+          invalid_arg "OASISUnixPath.make"
+
+
+  let dirname f =
+    try
+      String.sub f 0 (String.rindex f '/')
+    with Not_found ->
+      current_dir_name
+
+
+  let basename f =
+    try
+      let pos_start =
+        (String.rindex f '/') + 1
+      in
+        String.sub f pos_start ((String.length f) - pos_start)
+    with Not_found ->
+      f
+
+
+  let chop_extension f =
+    try
+      let last_dot =
+        String.rindex f '.'
+      in
+      let sub =
+        String.sub f 0 last_dot
+      in
+        try
+          let last_slash =
+            String.rindex f '/'
+          in
+            if last_slash < last_dot then
+              sub
+            else
+              f
+        with Not_found ->
+          sub
+
+    with Not_found ->
+      f
+
+
+  let capitalize_file f =
+    let dir = dirname f in
+    let base = basename f in
+    concat dir (OASISString.capitalize_ascii base)
+
+
+  let uncapitalize_file f =
+    let dir = dirname f in
+    let base = basename f in
+    concat dir (OASISString.uncapitalize_ascii base)
+
+
+end
+
+module OASISHostPath = struct
+(* # 22 "src/oasis/OASISHostPath.ml" *)
+
+
+  open Filename
+
+
+  module Unix = OASISUnixPath
+
+  let bash_cmd = ref ( fun () -> "" )
+
+  let use_bash () = ( !bash_cmd () ) <> ""
+
+
+  (* generic quote and unixquote are taken from ocaml source *)
+  let generic_quote quotequote s =
+    let l = String.length s in
+    let b = Buffer.create (l + 20) in
+      Buffer.add_char b '\'';
+      for i = 0 to l - 1 do
+        if s.[i] = '\'' then
+          Buffer.add_string b quotequote
+        else
+          Buffer.add_char b  s.[i]
+      done;
+      Buffer.add_char b '\'';
+      Buffer.contents b
+
+  let unixquote = generic_quote "'\\''"
+
+  let win = Sys.os_type = "Win32"
+
+  let quote str =
+    if win && use_bash () then
+      unixquote str
+    else
+      quote str
+
+  (* uniform_path (only called, if Sys.os_type = "Win32")
+   * - enforces uniform path seperators
+   * - strips trailing slashes (exceptions in case of C:\ and / )
+   * - removes (some) unnecessary file components like ./././
+   *)
+
+  let get_naccu accu str first pos =
+    (* I assume c//d is identic to c/d
+     * the only exception (Network devices \\xyz\asdf)
+     * is covered in uniform_path
+     *)
+    if first = pos then
+      accu
+    else
+      let nlen = pos - first in
+      let nstr = String.sub str first nlen in
+        (* test/././ is the same as test *)
+        if nlen = 1 && nstr = "." then
+          accu
+        (* a/b/../ is the same as a *)
+        else if nlen = 2 && nstr = ".." then
+          match accu with
+            | []      -> [ nstr ]
+            | ".."::_ -> nstr::accu
+            | hd::tl  -> tl
+        else
+          nstr::accu
+
+  let is_path_sep = function
+    | '\\' | '/' -> true
+    | _ -> false
+
+
+  let uniform_path path_sep = function
+    | "" -> "" (* Raise an exception? Or an possible intermediate result?
+               * Filename.basename and dirname also don't raise exceptions *)
+    | str ->
+        let rec iter accu str len first pos =
+          if pos >= len then
+            List.rev (get_naccu accu str first pos)
+          else
+            let next = succ pos in
+              match is_path_sep str.[pos] with
+                | true -> iter (get_naccu accu str first pos) str len next next
+                | false -> iter accu str len first next
+        in
+          let is_unix_root = is_path_sep str.[0] in
+          let len = String.length str in
+          let next_sep = len > 1 && is_path_sep str.[1] in
+          let is_network_root = is_unix_root && next_sep in
+          let is_currel = str.[0] = '.' && ( next_sep || len = 1 ) in
+          let l = iter [] str len 0 0 in
+          (* Trailing slashes are normally stripped.
+           * This is not possible in case of root folders
+           * Sys.file_exists "C:" is false, Sys.file_exists "C:\\" true
+           *)
+          let l_min =
+            match l with
+              | [] -> [ "" ]
+              | _ -> l
+          in
+          let l =
+            if is_network_root then
+              ""::""::l_min
+            else if is_unix_root then
+              ""::l_min
+            else if is_currel then
+              "."::l
+            else
+              match l with
+                | s :: [] ->
+                    (* root folders like C:\ *)
+                    if String.length s = 2 && s.[1] = ':' &&
+                      len > 2 && is_path_sep str.[2]
+                    then
+                      s :: [ "" ]
+                    else
+                      l
+                | _ -> l
+          in
+            String.concat path_sep l
+
+
+
+  let make =
+    function
+      | [] ->
+          invalid_arg "OASISHostPath.make"
+      | hd :: tl ->
+          List.fold_left Filename.concat hd tl
+
+
+  let of_unix str =
+    if win = false then
+      str
+    else
+      let path_sep =
+        if use_bash () then
+          "/"
+              else
+          "\\"
+      in
+        uniform_path path_sep str
+
+
+
+  (* see findlib's src/findlib/frontend.ml for details *)
+  let ocamlfind_unquote dir =
+    match Sys.os_type with
+      | "Cygwin"
+      | "Win32" ->
+        let len = String.length dir in
+          if len < 3 || dir.[0] <> '"' || dir.[len - 1] <> '"' ||
+            String.contains dir ' ' = false then
+            dir
+              else
+            String.sub dir 1 (len - 2)
+      | _ -> dir
 
-  let findlib_extra_files =
-    create "findlib_extra_files" beta
-      (fun () ->
-         s_ "Allow to install extra files for findlib libraries.")
 
-  let source_patterns =
-    create "source_patterns" alpha
-      (fun () ->
-         s_ "Customize mapping between module name and source file.")
 end
 
 module OASISSection = struct
@@ -2195,20 +2083,19 @@
     k, cs.cs_name
 
 
-  let string_of_section_kind =
-    function
+  let string_of_section sct =
+    let k, nm =
+      section_id sct
+    in
+      (match k with
       | `Library    -> "library"
       | `Object     -> "object"
       | `Executable -> "executable"
       | `Flag       -> "flag"
       | `SrcRepo    -> "src repository"
       | `Test       -> "test"
-      | `Doc        -> "doc"
-
-
-  let string_of_section sct =
-    let k, nm = section_id sct in
-    (string_of_section_kind k)^" "^nm
+         | `Doc        -> "doc")
+      ^" "^nm
 
 
   let section_find id scts =
@@ -2238,36 +2125,10 @@
   module SetSection = Set.Make(CSection)
 
 
-end
-
-module OASISBuildSection = struct
-(* # 22 "src/oasis/OASISBuildSection.ml" *)
-
-  open OASISTypes
-
-  (* Look for a module file, considering capitalization or not. *)
-  let find_module source_file_exists bs modul =
-    let possible_lst =
-      OASISSourcePatterns.all_possible_files
-        (bs.bs_interface_patterns @ bs.bs_implementation_patterns)
-        ~path:bs.bs_path
-        ~modul
-    in
-    match List.filter source_file_exists possible_lst with
-    | (fn :: _) as fn_lst -> `Sources (OASISUnixPath.chop_extension fn, fn_lst)
-    | [] ->
-      let open OASISUtils in
-      let _, rev_lst =
-        List.fold_left
-          (fun (set, acc) fn ->
-             let base_fn = OASISUnixPath.chop_extension fn in
-             if SetString.mem base_fn set then
-               set, acc
-             else
-               SetString.add base_fn set, base_fn :: acc)
-          (SetString.empty, []) possible_lst
-      in
-      `No_sources (List.rev rev_lst)
+end
+
+module OASISBuildSection = struct
+(* # 22 "src/oasis/OASISBuildSection.ml" *)
 
 
 end
@@ -2311,29 +2172,64 @@
 
 
   open OASISTypes
+  open OASISUtils
   open OASISGettext
+  open OASISSection
+
+
+  (* Look for a module file, considering capitalization or not. *)
+  let find_module source_file_exists bs modul =
+    let possible_base_fn =
+      List.map
+        (OASISUnixPath.concat bs.bs_path)
+        [modul;
+         OASISUnixPath.uncapitalize_file modul;
+         OASISUnixPath.capitalize_file modul]
+    in
+      (* TODO: we should be able to be able to determine the source for every
+       * files. Hence we should introduce a Module(source: fn) for the fields
+       * Modules and InternalModules
+       *)
+      List.fold_left
+        (fun acc base_fn ->
+           match acc with
+             | `No_sources _ ->
+                 begin
+                   let file_found =
+                     List.fold_left
+                       (fun acc ext ->
+                          if source_file_exists (base_fn^ext) then
+                            (base_fn^ext) :: acc
+                          else
+                            acc)
+                       []
+                       [".ml"; ".mli"; ".mll"; ".mly"]
+                   in
+                     match file_found with
+                       | [] ->
+                           acc
+                       | lst ->
+                           `Sources (base_fn, lst)
+                 end
+             | `Sources _ ->
+                 acc)
+        (`No_sources possible_base_fn)
+        possible_base_fn
 
-  let find_module ~ctxt source_file_exists cs bs modul =
-    match OASISBuildSection.find_module source_file_exists bs modul with
-    | `Sources _ as res -> res
-    | `No_sources _ as res ->
-      OASISMessage.warning
-        ~ctxt
-        (f_ "Cannot find source file matching module '%s' in library %s.")
-        modul cs.cs_name;
-      OASISMessage.warning
-        ~ctxt
-        (f_ "Use InterfacePatterns or ImplementationPatterns to define \
-             this file with feature %S.")
-        (OASISFeatures.source_patterns.OASISFeatures.name);
-      res
 
   let source_unix_files ~ctxt (cs, bs, lib) source_file_exists =
     List.fold_left
       (fun acc modul ->
-         match find_module ~ctxt source_file_exists cs bs modul with
-         | `Sources (base_fn, lst) -> (base_fn, lst) :: acc
-         | `No_sources _ -> acc)
+         match find_module source_file_exists bs modul with
+           | `Sources (base_fn, lst) ->
+               (base_fn, lst) :: acc
+           | `No_sources _ ->
+               OASISMessage.warning
+                 ~ctxt
+                 (f_ "Cannot find source file matching \
+                      module '%s' in library %s")
+                 modul cs.cs_name;
+               acc)
       []
       (lib.lib_modules @ lib.lib_internal_modules)
 
@@ -2349,12 +2245,19 @@
 
     let find_modules lst ext =
       let find_module modul =
-        match find_module ~ctxt source_file_exists cs bs modul with
-        | `Sources (_, [fn]) when ext <> "cmi"
+        match find_module source_file_exists bs modul with
+          | `Sources (base_fn, [fn]) when ext <> "cmi"
                                      && Filename.check_suffix fn ".mli" ->
           None (* No implementation files for pure interface. *)
-        | `Sources (base_fn, _) -> Some [base_fn]
-        | `No_sources lst -> Some lst
+          | `Sources (base_fn, _) ->
+              Some [base_fn]
+          | `No_sources lst ->
+              OASISMessage.warning
+                ~ctxt
+                (f_ "Cannot find source file matching \
+                     module '%s' in library %s")
+                modul cs.cs_name;
+              Some lst
       in
       List.fold_left
         (fun acc nm ->
@@ -2399,12 +2302,15 @@
         else [".cmi"; ".cmti"; ".cmt"; ".annot"]
       in
       List.map
-        (List.fold_left
-           (fun accu s ->
+        begin
+          List.fold_left
+            begin fun accu s ->
               let dot = String.rindex s '.' in
               let base = String.sub s 0 dot in
-              List.map ((^) base) sufx @ accu)
-           [])
+              List.map ((^) base) sufx @ accu
+            end
+            []
+        end
         (find_modules lib.lib_modules "cmi")
     in
 
@@ -2430,23 +2336,26 @@
         [cs.cs_name^".cmxa"] :: [cs.cs_name^ext_lib] :: acc
       in
       match bs.bs_compiled_object with
-      | Native -> byte (native acc_nopath)
-      | Best when is_native -> byte (native acc_nopath)
-      | Byte | Best -> byte acc_nopath
+          | Native ->
+              byte (native acc_nopath)
+          | Best when is_native ->
+              byte (native acc_nopath)
+          | Byte | Best ->
+              byte acc_nopath
     in
 
     (* Add C library to be built *)
     let acc_nopath =
-      if bs.bs_c_sources <> [] then begin
+      if bs.bs_c_sources <> [] then
+        begin
         ["lib"^cs.cs_name^"_stubs"^ext_lib]
         ::
-        if has_native_dynlink then
-          ["dll"^cs.cs_name^"_stubs"^ext_dll] :: acc_nopath
-        else
-          acc_nopath
-      end else begin
+          ["dll"^cs.cs_name^"_stubs"^ext_dll]
+          ::
         acc_nopath
       end
+      else
+        acc_nopath
     in
 
     (* All the files generated *)
@@ -2468,27 +2377,19 @@
   open OASISGettext
 
 
-  let find_module ~ctxt source_file_exists cs bs modul =
-    match OASISBuildSection.find_module source_file_exists bs modul with
-    | `Sources _ as res -> res
-    | `No_sources _ as res ->
-      OASISMessage.warning
-        ~ctxt
-        (f_ "Cannot find source file matching module '%s' in object %s.")
-        modul cs.cs_name;
-      OASISMessage.warning
-        ~ctxt
-        (f_ "Use InterfacePatterns or ImplementationPatterns to define \
-             this file with feature %S.")
-        (OASISFeatures.source_patterns.OASISFeatures.name);
-      res
-
   let source_unix_files ~ctxt (cs, bs, obj) source_file_exists =
     List.fold_left
       (fun acc modul ->
-         match find_module ~ctxt source_file_exists cs bs modul with
-         | `Sources (base_fn, lst) -> (base_fn, lst) :: acc
-         | `No_sources _ -> acc)
+         match OASISLibrary.find_module source_file_exists bs modul with
+           | `Sources (base_fn, lst) ->
+               (base_fn, lst) :: acc
+           | `No_sources _ ->
+               OASISMessage.warning
+                 ~ctxt
+                 (f_ "Cannot find source file matching \
+                      module '%s' in object %s")
+                 modul cs.cs_name;
+               acc)
       []
       obj.obj_modules
 
@@ -2500,9 +2401,15 @@
       (cs, bs, obj) =
 
     let find_module ext modul =
-      match find_module ~ctxt source_file_exists cs bs modul with
+      match OASISLibrary.find_module source_file_exists bs modul with
       | `Sources (base_fn, _) -> [base_fn ^ ext]
-      | `No_sources lst -> lst
+        | `No_sources lst ->
+          OASISMessage.warning
+            ~ctxt
+            (f_ "Cannot find source file matching \
+                 module '%s' in object %s")
+            modul cs.cs_name ;
+          lst
     in
 
     let header, byte, native, c_object, f =
@@ -2537,6 +2444,7 @@
   open OASISTypes
   open OASISUtils
   open OASISGettext
+  open OASISSection
 
 
   type library_name = name
@@ -2554,7 +2462,6 @@
                   common_section *
                   build_section *
                   [`Library of library | `Object of object_] *
-                  unix_dirname option *
                   group_t list)
 
 
@@ -2737,31 +2644,17 @@
       add_children (OASISString.nsplit fndlb_fullname '.') mp
     in
 
-    let unix_directory dn lib =
-      let directory =
-        match lib with
-        | `Library lib -> lib.lib_findlib_directory
-        | `Object obj -> obj.obj_findlib_directory
-      in
-      match dn, directory with
-      | None, None -> None
-      | None, Some dn | Some dn, None -> Some dn
-      | Some dn1, Some dn2 -> Some (OASISUnixPath.concat dn1 dn2)
-    in
-
-    let rec group_of_tree dn mp =
+    let rec group_of_tree mp =
       MapString.fold
         (fun nm node acc ->
            let cur =
              match node with
              | Node (Some (cs, bs, lib), children) ->
-               let current_dn = unix_directory dn lib in
-               Package (nm, cs, bs, lib, current_dn, group_of_tree current_dn children)
+                   Package (nm, cs, bs, lib, group_of_tree children)
              | Node (None, children) ->
-               Container (nm, group_of_tree dn children)
+                   Container (nm, group_of_tree children)
              | Leaf (cs, bs, lib) ->
-               let current_dn = unix_directory dn lib in
-               Package (nm, cs, bs, lib, current_dn, [])
+                   Package (nm, cs, bs, lib, [])
            in
            cur :: acc)
         mp []
@@ -2781,7 +2674,9 @@
         pkg.sections
     in
 
-    let groups = group_of_tree None group_mp in
+    let groups =
+      group_of_tree group_mp
+    in
 
     let library_name_of_findlib_name =
       lazy begin
@@ -2807,7 +2702,7 @@
   let findlib_of_group =
     function
       | Container (fndlb_nm, _)
-      | Package (fndlb_nm, _, _, _, _, _) -> fndlb_nm
+      | Package (fndlb_nm, _, _, _, _) -> fndlb_nm
 
 
   let root_of_group grp =
@@ -2823,7 +2718,7 @@
                  res)
             None
             children
-        | Package (_, cs, bs, lib, _, _) ->
+        | Package (_, cs, bs, lib, _) ->
           Some (cs, bs, lib)
     in
     match root_lib_aux grp with
@@ -2876,25 +2771,221 @@
   open OASISMessage
 
 
+
+
+  (* In general, there is no chance to quote properly with the current
+   * settings. ( This is only a problem, if BaseCustom.run is used (e.g
+   * test commands, PreConfigure,....). Most of the time, OASISExec.run
+   * is used with enabled quoting.)
+   *
+   * "$rm" should ideally expand to 'rm -f' (no quotes), but "$test_exec"
+   * should ideally expand to '"C:\Program Files\dir\test.exe"' (with
+   * quotes). Paths with spaces are common on Windows, so this problem
+   * can't be ignored.
+   *
+   * Using a command with additional parameters is quite useful, not only
+   * for trivial cases like $rm. You could add an additional parameter
+   * for $make in order to use a special compatibility mode, on windows
+   * you can use it to inform ocaml that a certain program is a shell
+   * script ('sh.exe pcre-config').
+   *
+   * An additional parameter (e.g. $rm_switches) would be ugly,
+   * especially for *nix users, who don't use space characters in their
+   * installation paths anyway.
+   *
+   * I use the following workaround, which should work most of the time:
+   *
+   * - if cmd doesn't contains spaces or other suspicious characters, it
+   * can be quoted in the usual way (not ambigous, I think)
+   *
+   * - if cmd does contain spaces, a file with this name exists, and the
+   * beginning of cmd looks like a absolute pathname
+   * ('\\test\dir\foo.exe' or "C:\\sa df\\foo.exe" - not "foo.exe" ), I
+   * will also quote it. (ambigous, there could be "C:\bin\rm.exe" and
+   * "C:\bin\rm -f.exe").  Relative filenames are not considered, because
+   * I assume the source code folder contains only well named files and
+   * relative paths like "../../make.exe" are uncommon (autoconf even
+   * rejects them) *)
+
+
+  (* stricter settings as for regular windows batch lines
+   * necessary because of shell comannds like:
+   *   LC_ALL=C make ....
+   *)
+  let is_dubious_char = function
+    | '+' | '~' | ':' | '.' | '-' | '_' | '/' | '\\' -> false
+    | c ->
+      OASISString.is_digit c = false &&
+      OASISString.is_alpha c = false
+
+
+  let win_quote_needed str =
+    let f = function
+      (* this list is not exhaustive. Feel free to added common chars, that
+       * can be passed to cmd.exe without quoting *)
+      | 'a' .. 'z'  | 'A' .. 'Z' | '0' .. '9'
+      | '_' | '-' | '~' | '.' | ':' | ',' | '\\' -> false
+      | _ -> true
+    in
+      str = "" || OASISString.exists f str
+
+  let is_simple_command str =
+    String.length str > 0 &&
+    not (OASISString.exists is_dubious_char str)
+
+  let is_path_sep = function
+    | '/' | '\\' -> true
+    | _ -> false
+
+  let starts_with_absolute_path cmd =
+    let len = String.length cmd in
+      if len < 3 then
+        false
+      else
+        let c0 = cmd.[0] in
+        let c1 = cmd.[1] in
+          if is_path_sep c0 && is_path_sep c1 then (* network devices: "//" *)
+            true
+          else if len = 3 then
+            false
+          else  (* C:\.... *)
+            OASISString.is_alpha c0 && c1 = ':' && is_path_sep cmd.[2]
+
+  let exe_exts = lazy
+    begin
+      let exts =
+        try
+          OASISString.nsplit
+            (Sys.getenv "PATHEXT")
+            ';'
+        with
+          | Not_found -> []
+      in
+      let exts' =
+        List.filter
+          ( fun a -> a <> "" && a.[0] = '.' && a <> ".exe" )
+          (List.map OASISString.lowercase_ascii exts) (* windows file system doesn't care *)
+      in
+        ".exe"::exts' (* .exe first, most common *)
+    end
+
+  let exe_file_exists fln =
+    Sys.file_exists fln ||
+    List.exists
+      (fun a -> Sys.file_exists ( fln ^ a ) )
+      (Lazy.force exe_exts)
+
+
+  let quote_anyway cmd =
+    if Sys.os_type <> "Win32" then (* workaround for windows only *)
+      false
+    else if is_simple_command cmd then
+      true
+    else
+      OASISString.exists OASISString.is_whitespace cmd &&
+        starts_with_absolute_path cmd &&
+        exe_file_exists cmd
+
+
+  let run_bash ~ctxt ?f_exit_code ?(quote=true) cmd args =
+    let fn = Filename.temp_file "oasis-" ".sh" in
+    let fn_deleted = ref false in
+      try
+        begin
+          let ch = open_out_bin fn in
+          let ch_closed = ref false in
+            try
+              begin
+                let cmd =
+                  if quote || quote_anyway cmd then
+                    OASISHostPath.quote (OASISHostPath.of_unix cmd)
+                  else
+                    cmd
+                in
+                  output_string ch cmd;
+                  List.iter
+                    ( fun s -> output_char ch ' '; output_string ch s )
+                    args ;
+                  output_char ch '\n';
+                  ch_closed:=true ;
+                  close_out ch;
+                  let bash = !OASISHostPath.bash_cmd () in
+                  let add_quotes = ref false in
+                  let shell_cmd =
+                    if Sys.os_type <> "Win32" then
+                      Filename.quote bash
+                    else
+                      if win_quote_needed bash = false then
+                        bash
+                      else
+                        begin
+                          add_quotes := true;
+                          Filename.quote bash
+                        end
+                  in
+                  let cmdline_orig = String.concat " " (cmd :: args) in
+                  let cmdline =
+                    let s = shell_cmd ^ " " ^ (Filename.quote fn) in
+                      if !add_quotes then
+                        "\"" ^ s ^ "\""
+                      else
+                        s
+                  in
+                    info ~ctxt (f_ "Running command '%s'") cmdline_orig;
+                    let ret = Sys.command cmdline in
+                      fn_deleted := true;
+                      Sys.remove fn;
+                      match f_exit_code, ret with
+                        | None, 0 -> ()
+                        | None, i ->
+                            failwithf
+                              (f_ "Command '%s' terminated with error code %d")
+                              cmdline_orig i
+                        | Some f, i ->
+                            f i
+              end
+            with
+              | x when !ch_closed = false ->
+                  close_out_noerr ch;
+                  raise x
+        end
+      with
+        | x when !fn_deleted = false ->
+            (try Sys.remove fn with _ -> () ) ;
+            raise x
+
   (* TODO: I don't like this quote, it is there because $(rm) foo expands to
    * 'rm -f' foo...
   *)
-  let run ~ctxt ?f_exit_code ?(quote=true) cmd args =
+
+  let run_default ~ctxt ?f_exit_code ?(quote=true) cmd args =
+    let add_quotes = ref false in
     let cmd =
-      if quote then
+      if quote || quote_anyway cmd then
         if Sys.os_type = "Win32" then
-          if String.contains cmd ' ' then
-            (* Double the 1st double quote... win32... sigh *)
-            "\""^(Filename.quote cmd)
-          else
+          begin
+            if win_quote_needed cmd = false then
             cmd
         else
+              begin
+                (* Double the 1st double quote... win32... sigh *)
+                (* Above comment ist false. The whole string must be quoted.
+                 * However, an error is only triggered, if args contains also
+                 * quoted parameters *)
+                add_quotes := true;
+                Filename.quote cmd
+              end
+          end
+        else
           Filename.quote cmd
       else
         cmd
     in
     let cmdline =
-      String.concat " " (cmd :: args)
+      let s = String.concat " " (cmd :: args) in
+        match !add_quotes with
+          | true -> "\"" ^ s ^ "\""
+          | false -> s
     in
     info ~ctxt (f_ "Running command '%s'") cmdline;
     match f_exit_code, Sys.command cmdline with
@@ -2907,6 +2998,13 @@
         f i
 
 
+
+  let run ~ctxt ?f_exit_code ?quote cmd args =
+    if OASISHostPath.use_bash () then
+      run_bash ~ctxt ?f_exit_code ?quote cmd args
+    else
+      run_default ~ctxt ?f_exit_code ?quote cmd args
+
   let run_read_output ~ctxt ?f_exit_code cmd args =
     let fn =
       Filename.temp_file "oasis-" ".txt"
@@ -3016,7 +3114,7 @@
     ) alternatives
 
 
-  let which ~ctxt prg =
+  let which ?(plain=false) ?ctxt prg =
     let path_sep =
       match Sys.os_type with
         | "Win32" ->
@@ -3028,11 +3126,17 @@
     let exec_ext =
       match Sys.os_type with
         | "Win32" ->
-          "" :: (OASISString.nsplit (Sys.getenv "PATHEXT") path_sep)
+            "" :: (List.map OASISString.lowercase_ascii (OASISString.nsplit (Sys.getenv "PATHEXT") path_sep))
         | _ ->
           [""]
     in
+    let p =
     find_file ~case_sensitive:false [path_lst; [prg]] exec_ext
+    in
+    if plain then
+      p
+    else
+      OASISHostPath.of_unix p
 
 
   (**/**)
@@ -3049,32 +3153,55 @@
       dn
 
 
-  let q = Filename.quote
+  let q s = OASISHostPath.quote (OASISHostPath.of_unix s)
   (**/**)
 
 
   let cp ~ctxt ?(recurse=false) src tgt =
     if recurse then
-      match Sys.os_type with
-        | "Win32" ->
-          OASISExec.run ~ctxt
-            "xcopy" [q src; q tgt; "/E"]
-        | _ ->
-          OASISExec.run ~ctxt
-            "cp" ["-r"; q src; q tgt]
+      (*
+        'xcopy /E' and 'cp -r' don't have the same semantic!
+        -dir2 does exist:
+          xcopy dir dir2 /E -> copys content of dir into dir2 (dir2/dir doesn't exist!)
+          cp -r dir dir2    -> copys dir to dir2 (dir2/dir does exist!)
+        -dir2 doesn't exist:
+          xcopy dir dir2 /E -> request on command line, if dir2 is an directory or file.
+          cp -r dir dir2    -> dir and dir2 have the same content (dir2/dir doesn't exist)
+        Probably, there are even more differences,....
+      *)
+      if Sys.os_type = "Win32" && OASISHostPath.use_bash () = false then
+        let tgt_real =
+          if Sys.file_exists tgt = false then
+            begin
+              OASISExec.run ~ctxt "md" [q tgt];
+              tgt
+            end
     else
-      OASISExec.run ~ctxt
-        (match Sys.os_type with
-          | "Win32" -> "copy"
-          | _ -> "cp")
-        [q src; q tgt]
+            let base = Filename.basename src in
+            if base = "." then
+              tgt
+            else
+              let tgt_real = Filename.concat tgt base in
+                if Sys.file_exists tgt_real = false then
+                  OASISExec.run ~ctxt "md" [q tgt_real];
+              tgt_real
+        in
+        OASISExec.run ~ctxt "xcopy" [q src; q tgt_real; "/E" ; "/Q" ; "/Y"]
+      else
+        OASISExec.run ~ctxt "cp" ["-r"; q src; q tgt]
+    else
+      if Sys.os_type = "Win32" && OASISHostPath.use_bash () = false then
+        OASISExec.run ~ctxt "copy" [q src; q tgt ; "/Y"]
+      else
+        OASISExec.run ~ctxt "cp" [q src; q tgt]
 
 
   let mkdir ~ctxt tgt =
     OASISExec.run ~ctxt
-      (match Sys.os_type with
-        | "Win32" -> "md"
-        | _ -> "mkdir")
+      ( if Sys.os_type = "Win32" && not (OASISHostPath.use_bash ()) then
+          "md"
+        else
+          "mkdir" )
       [q tgt]
 
 
@@ -3103,10 +3230,9 @@
 
   let rmdir ~ctxt tgt =
     if Sys.readdir tgt = [||] then begin
-      match Sys.os_type with
-        | "Win32" ->
+      if Sys.os_type = "Win32" && OASISHostPath.use_bash () = false then
           OASISExec.run ~ctxt "rd" [q tgt]
-        | _ ->
+      else
           OASISExec.run ~ctxt "rm" ["-r"; q tgt]
     end else begin
       OASISMessage.error ~ctxt
@@ -3160,7 +3286,7 @@
 end
 
 
-# 3165 "setup.ml"
+# 3291 "setup.ml"
 module BaseEnvLight = struct
 (* # 22 "src/base/BaseEnvLight.ml" *)
 
@@ -3171,12 +3297,24 @@
   type t = string MapString.t
 
 
-  let default_filename = Filename.concat (Sys.getcwd ()) "setup.data"
+  let default_filename =
+    Filename.concat
+      (Sys.getcwd ())
+      "setup.data"
 
 
-  let load ?(allow_empty=false) ?(filename=default_filename) ?stream () =
-    let line = ref 1 in
-    let lexer st =
+  let load ?(allow_empty=false) ?(filename=default_filename) () =
+    if Sys.file_exists filename then
+      begin
+        let chn =
+          open_in_bin filename
+        in
+        let st =
+          Stream.of_channel chn
+        in
+        let line =
+          ref 1
+        in
       let st_line =
         Stream.from
           (fun _ ->
@@ -3186,32 +3324,36 @@
                | c -> Some c
              with Stream.Failure -> None)
       in
+        let lexer =
       Genlex.make_lexer ["="] st_line
     in
-    let rec read_file lxr mp =
-      match Stream.npeek 3 lxr with
+        let rec read_file mp =
+          match Stream.npeek 3 lexer with
       | [Genlex.Ident nm; Genlex.Kwd "="; Genlex.String value] ->
-        Stream.junk lxr; Stream.junk lxr; Stream.junk lxr;
-        read_file lxr (MapString.add nm value mp)
-      | [] -> mp
+                Stream.junk lexer;
+                Stream.junk lexer;
+                Stream.junk lexer;
+                read_file (MapString.add nm value mp)
+            | [] ->
+                mp
       | _ ->
         failwith
-          (Printf.sprintf "Malformed data file '%s' line %d" filename !line)
+                  (Printf.sprintf
+                     "Malformed data file '%s' line %d"
+                     filename !line)
     in
-    match stream with
-    | Some st -> read_file (lexer st) MapString.empty
-    | None ->
-      if Sys.file_exists filename then begin
-        let chn = open_in_bin filename in
-        let st = Stream.of_channel chn in
-        try
-          let mp = read_file (lexer st) MapString.empty in
-          close_in chn; mp
-        with e ->
-          close_in chn; raise e
-      end else if allow_empty then begin
+        let mp =
+          read_file MapString.empty
+        in
+          close_in chn;
+          mp
+      end
+    else if allow_empty then
+      begin
         MapString.empty
-      end else begin
+      end
+    else
+      begin
         failwith
           (Printf.sprintf
              "Unable to load environment, the file '%s' doesn't exist."
@@ -3218,8 +3360,11 @@
              filename)
       end
 
+
   let rec var_expand str env =
-    let buff = Buffer.create ((String.length str) * 2) in
+    let buff =
+      Buffer.create ((String.length str) * 2)
+    in
     Buffer.add_substitute
       buff
       (fun var ->
@@ -3235,12 +3380,18 @@
     Buffer.contents buff
 
 
-  let var_get name env = var_expand (MapString.find name env) env
-  let var_choose lst env = OASISExpr.choose (fun nm -> var_get nm env) lst
+  let var_get name env =
+    var_expand (MapString.find name env) env
+
+
+  let var_choose lst env =
+    OASISExpr.choose
+      (fun nm -> var_get nm env)
+      lst
 end
 
 
-# 3245 "setup.ml"
+# 3396 "setup.ml"
 module BaseContext = struct
 (* # 22 "src/base/BaseContext.ml" *)
 
@@ -3284,7 +3435,6 @@
 
   open OASISGettext
   open OASISUtils
-  open OASISContext
   open PropList
 
 
@@ -3316,22 +3466,26 @@
     }
 
 
-  let schema = Schema.create "environment"
+  let schema =
+    Schema.create "environment"
 
 
   (* Environment data *)
-  let env = Data.create ()
+  let env =
+    Data.create ()
 
 
   (* Environment data from file *)
-  let env_from_file = ref MapString.empty
+  let env_from_file =
+    ref MapString.empty
 
 
   (* Lexer for var *)
-  let var_lxr = Genlex.make_lexer []
+  let var_lxr =
+    Genlex.make_lexer []
 
 
-  let rec var_expand str =
+  let rec var_expand ?(quoted=false) str =
     let buff =
       Buffer.create ((String.length str) * 2)
     in
@@ -3359,7 +3513,11 @@
              | [Genlex.Ident "ocaml_escaped"; Genlex.String s] ->
                String.escaped s
              | [Genlex.Ident nm] ->
-               var_get nm
+                     let s = var_get nm in
+                     if quoted then
+                       OASISHostPath.quote s
+                     else
+                       s
              | _ ->
                failwithf
                  (f_ "Unknown expression '%s' in variable expansion of %s.")
@@ -3451,7 +3609,7 @@
     let var_get_low lst =
       let errors, res =
         List.fold_left
-          (fun (errors, res) (_, v) ->
+          (fun (errors, res) (o, v) ->
              if res = None then
                begin
                  try
@@ -3494,7 +3652,7 @@
         ~parse:(fun ?(context=ODefault) s -> [context, fun () -> s])
         ~print:var_get_low
         ~default
-        ~update:(fun ?context:_ x old_x -> x @ old_x)
+        ~update:(fun ?context x old_x -> x @ old_x)
         ?help
         extra
     in
@@ -3532,7 +3690,7 @@
       end
 
 
-  let var_ignore (_: unit -> string) = ()
+  let var_ignore (e: unit -> string) = ()
 
 
   let print_hidden =
@@ -3557,34 +3715,12 @@
          schema)
 
 
-  let default_filename = in_srcdir "setup.data"
+  let default_filename =
+    BaseEnvLight.default_filename
 
 
-  let load ~ctxt ?(allow_empty=false) ?(filename=default_filename) () =
-    let open OASISFileSystem in
-    env_from_file :=
-      let repr_filename = ctxt.srcfs#string_of_filename filename in
-      if ctxt.srcfs#file_exists filename then begin
-        let buf = Buffer.create 13 in
-        defer_close
-          (ctxt.srcfs#open_in ~mode:binary_in filename)
-          (read_all buf);
-        defer_close
-          (ctxt.srcfs#open_in ~mode:binary_in filename)
-          (fun rdr ->
-             OASISMessage.info ~ctxt "Loading environment from %S." repr_filename;
-             BaseEnvLight.load ~allow_empty
-               ~filename:(repr_filename)
-               ~stream:(stream_of_reader rdr)
-               ())
-      end else if allow_empty then begin
-        BaseEnvLight.MapString.empty
-      end else begin
-        failwith
-          (Printf.sprintf
-             (f_ "Unable to load environment, the file '%s' doesn't exist.")
-             repr_filename)
-      end
+  let load ?allow_empty ?filename () =
+    env_from_file := BaseEnvLight.load ?allow_empty ?filename ()
 
 
   let unload () =
@@ -3592,22 +3728,27 @@
     Data.clear env
 
 
-  let dump ~ctxt ?(filename=default_filename) () =
-    let open OASISFileSystem in
-    defer_close
-      (ctxt.OASISContext.srcfs#open_out ~mode:binary_out filename)
-      (fun wrtr ->
-         let buf = Buffer.create 63 in
+  let dump ?(filename=default_filename) () =
+    let chn =
+      open_out_bin filename
+    in
          let output nm value =
-           Buffer.add_string buf (Printf.sprintf "%s=%S\n" nm value)
+      Printf.fprintf chn "%s=%S\n" nm value
          in
          let mp_todo =
            (* Dump data from schema *)
            Schema.fold
              (fun mp_todo nm def _ ->
-                if def.dump then begin
+           if def.dump then
+             begin
                   try
-                    output nm (Schema.get schema env nm)
+                 let value =
+                   Schema.get
+                     schema
+                     env
+                     nm
+                 in
+                   output nm value
                   with Not_set _ ->
                     ()
                 end;
@@ -3617,7 +3758,10 @@
          in
          (* Dump data defined outside of schema *)
          MapString.iter output mp_todo;
-         wrtr#output buf)
+
+      (* End of the dump *)
+      close_out chn
+
 
   let print () =
     let printable_vars =
@@ -3626,7 +3770,12 @@
            if not def.hide || bool_of_string (print_hidden ()) then
              begin
                try
-                 let value = Schema.get schema env nm in
+                 let value =
+                   Schema.get
+                     schema
+                     env
+                     nm
+                 in
                  let txt =
                    match short_descr_opt with
                      | Some s -> s ()
@@ -3646,21 +3795,22 @@
         (List.rev_map String.length
            (List.rev_map fst printable_vars))
     in
-    let dot_pad str = String.make ((max_length - (String.length str)) + 3) '.' in
-    Printf.printf "\nConfiguration:\n";
+    let dot_pad str =
+      String.make ((max_length - (String.length str)) + 3) '.'
+    in
+
+    Printf.printf "\nConfiguration: \n";
     List.iter
       (fun (name, value) ->
-         Printf.printf "%s: %s" name (dot_pad name);
-         if value = "" then
-           Printf.printf "\n"
-         else
-           Printf.printf " %s\n" value)
+        Printf.printf "%s: %s %s\n" name (dot_pad name) value)
       (List.rev printable_vars);
     Printf.printf "\n%!"
 
 
   let args () =
-    let arg_concat = OASISUtils.varname_concat ~hyphen:'-' in
+    let arg_concat =
+      OASISUtils.varname_concat ~hyphen:'-'
+    in
     [
       "--override",
       Arg.Tuple
@@ -3897,9 +4047,11 @@
     in
     let findlib_dir pkg =
       let dir =
+        OASISHostPath.of_unix (
+          OASISHostPath.ocamlfind_unquote (
         OASISExec.run_read_one_line ~ctxt:!BaseContext.default
           (ocamlfind ())
-          ["query"; "-format"; "%d"; pkg]
+              ["query"; "-format"; "%d"; pkg] ) )
       in
       if Sys.file_exists dir && Sys.is_directory dir then
         dir
@@ -4029,6 +4181,9 @@
       match nm with
         | "ocaml_version" ->
           "version", chop_version_suffix
+        | "standard_library"
+        | "standard_library_default" ->
+            nm, ( fun x -> OASISHostPath.of_unix x)
         | _ -> nm, (fun x -> x)
     in
     var_redefine
@@ -4056,6 +4211,7 @@
 
   open OASISGettext
   open OASISTypes
+  open OASISExpr
   open BaseCheck
   open BaseEnv
 
@@ -4168,14 +4324,43 @@
 
 
   let (/) a b =
-    if os_type () = Sys.os_type then
+    let os = os_type () in
+      if os = Sys.os_type then
+        if Sys.os_type = "Win32" && OASISHostPath.use_bash () then
+          OASISUnixPath.concat a b
+        else
       Filename.concat a b
-    else if os_type () = "Unix" || os_type () = "Cygwin" then
+      else if os = "Unix" then
       OASISUnixPath.concat a b
     else
       OASISUtils.failwithf (f_ "Cannot handle os_type %s filename concat")
         (os_type ())
   (**/**)
+  let auto_bash =
+    lazy (
+      try
+        OASISFileUtil.which ~plain:true "dash"
+      with
+      | Not_found | Sys_error _ ->
+        try
+          OASISFileUtil.which ~plain:true "bash"
+        with
+        | Not_found | Sys_error _ -> "" )
+
+  let auto_bash () =
+    if Sys.os_type <> "Win32" then
+      ""
+    else
+      Lazy.force auto_bash
+
+
+  let bash_cmd =
+    var_define
+      ~short_desc:(fun () -> s_ "Enforced bash shell:")
+      ~cli:CLIAuto
+      ~arg_help:"program"
+      "use_bash"
+      auto_bash
 
 
   let prefix =
@@ -4184,10 +4369,30 @@
       (fun () ->
          match os_type () with
            | "Win32" ->
+               let getenv w =
+                 try
+                   Some(Sys.getenv w)
+                 with
+                   | Not_found -> None
+               in
+               let s =
+                 if Sys.word_size = 64 then
+                   getenv "ProgramW6432"
+                 else
+                   None
+               in
+               let s =
+                 if s = None then
+                   getenv "PROGRAMFILES"
+                 else
+                   s
+               in
              let program_files =
-               Sys.getenv "PROGRAMFILES"
+                 match s with
+                   | None -> "C:\\Program Files"
+                   | Some x -> x
              in
-             program_files/(pkg_name ())
+                 OASISHostPath.of_unix (program_files/(pkg_name ()))
            | _ ->
              "/usr/local")
 
@@ -4273,7 +4478,15 @@
   let docdir =
     p "docdir"
       (fun () -> s_ "Documentation root")
-      (fun () -> "$datarootdir"/"doc"/"$pkg_name")
+      (fun () ->
+        (* TODO: (Windows only?) "$pkg_name" is not always substituted
+         * (at least if datarootdir contains spaces or other garbage)
+         * I haven't looked up why.
+         *)
+        match os_type () with
+          | "Win32" -> "$datarootdir"/"doc"/ ( pkg_name () )
+          | _ -> "$datarootdir"/"doc"/"$pkg_name"
+      )
 
 
   let htmldir =
@@ -4347,9 +4560,10 @@
       ~short_desc:(fun () -> s_ "Remove a file.")
       "rm"
       (fun () ->
-         match os_type () with
-           | "Win32" -> "del"
-           | _ -> "rm -f")
+         if not (OASISHostPath.use_bash ()) && os_type () = "Win32" then
+           "del"
+         else
+           "rm -f" )
 
 
   let rmdir =
@@ -4357,9 +4571,10 @@
       ~short_desc:(fun () -> s_ "Remove a directory.")
       "rmdir"
       (fun () ->
-         match os_type () with
-           | "Win32" -> "rd"
-           | _ -> "rm -rf")
+         if not (OASISHostPath.use_bash ()) && os_type () = "Win32" then
+           "rd"
+         else
+           "rm -rf")
 
 
   let debug =
@@ -4423,14 +4638,29 @@
            let has_native_dynlink =
              let ocamlfind = ocamlfind () in
              try
-               let fn =
+                 (* -format %d/%a doesn't work, because ocamlfind quotes %d
+                  * and %a separatly *)
+                 let fn1 =
+                   OASISHostPath.ocamlfind_unquote (
+                     OASISExec.run_read_one_line
+                       ~ctxt:!BaseContext.default
+                       ocamlfind
+                       ["query"; "-predicates"; "native"; "dynlink";
+                        "-format"; "%d"] )
+                 in
+                 let fn2 =
+                   OASISHostPath.ocamlfind_unquote (
                  OASISExec.run_read_one_line
                    ~ctxt:!BaseContext.default
                    ocamlfind
                    ["query"; "-predicates"; "native"; "dynlink";
-                    "-format"; "%d/%a"]
+                        "-format"; "%a"] )
                in
-               Sys.file_exists fn
+                   if fn1 <> "" && fn2 <> "" &&
+                     Sys.file_exists (Filename.concat fn1 fn2) then
+                     true
+                   else
+                     false
              with _ ->
                false
            in
@@ -4457,6 +4687,8 @@
     rpkg := Some pkg;
     List.iter (fun f -> f pkg.oasis_version) !var_cond
 
+  let () =
+    OASISHostPath.bash_cmd := bash_cmd
 end
 
 module BaseFileAB = struct
@@ -4466,28 +4698,47 @@
   open BaseEnv
   open OASISGettext
   open BaseMessage
-  open OASISContext
 
 
   let to_filename fn =
+    let fn =
+      OASISHostPath.of_unix fn
+    in
     if not (Filename.check_suffix fn ".ab") then
-      warning (f_ "File '%s' doesn't have '.ab' extension") fn;
-    OASISFileSystem.of_unix_filename (Filename.chop_extension fn)
+        warning
+          (f_ "File '%s' doesn't have '.ab' extension")
+          fn;
+      Filename.chop_extension fn
 
 
-  let replace ~ctxt fn_lst =
-    let open OASISFileSystem in
-    let ibuf, obuf = Buffer.create 13, Buffer.create 13 in
+  let replace fn_lst =
+    let buff =
+      Buffer.create 13
+    in
     List.iter
       (fun fn ->
-         Buffer.clear ibuf; Buffer.clear obuf;
-         defer_close
-           (ctxt.srcfs#open_in (of_unix_filename fn))
-           (read_all ibuf);
-         Buffer.add_string obuf (var_expand (Buffer.contents ibuf));
-         defer_close
-           (ctxt.srcfs#open_out (to_filename fn))
-           (fun wrtr -> wrtr#output obuf))
+           let fn =
+             OASISHostPath.of_unix fn
+           in
+           let chn_in =
+             open_in fn
+           in
+           let chn_out =
+             open_out (to_filename fn)
+           in
+             (
+               try
+                 while true do
+                  Buffer.add_string buff (var_expand (input_line chn_in));
+                  Buffer.add_char buff '\n'
+                 done
+               with End_of_file ->
+                 ()
+             );
+             Buffer.output_buffer chn_out buff;
+             Buffer.clear buff;
+             close_in chn_in;
+             close_out chn_out)
       fn_lst
 end
 
@@ -4496,16 +4747,15 @@
 
 
   open OASISUtils
-  open OASISContext
-  open OASISGettext
-  open OASISFileSystem
 
 
-  let default_filename = in_srcdir "setup.log"
+  let default_filename =
+    Filename.concat
+      (Filename.dirname BaseEnv.default_filename)
+      "setup.log"
 
 
-  let load ~ctxt () =
-    let module SetTupleString =
+  module SetTupleString =
       Set.Make
         (struct
           type t = string * string
@@ -4514,74 +4764,109 @@
             | 0 -> String.compare s12 s22
             | n -> n
         end)
+
+
+  let load () =
+    if Sys.file_exists default_filename then
+      begin
+        let chn =
+          open_in default_filename
+        in
+        let scbuf =
+          Scanf.Scanning.from_file default_filename
     in
-    if ctxt.srcfs#file_exists default_filename then begin
-      defer_close
-        (ctxt.srcfs#open_in default_filename)
-        (fun rdr ->
-           let line = ref 1 in
-           let lxr = Genlex.make_lexer [] (stream_of_reader rdr) in
            let rec read_aux (st, lst) =
-             match Stream.npeek 2 lxr with
-             | [Genlex.String e; Genlex.String d] ->
-               let t = e, d in
-               Stream.junk lxr; Stream.junk lxr;
+          if not (Scanf.Scanning.end_of_input scbuf) then
+            begin
+              let acc =
+                try
+                  Scanf.bscanf scbuf "%S %S\n"
+                    (fun e d ->
+                       let t =
+                         e, d
+                       in
                if SetTupleString.mem t st then
-                 read_aux (st, lst)
+                           st, lst
                else
-                 read_aux (SetTupleString.add t st, t :: lst)
-             | [] -> List.rev lst
-             | _ ->
-               failwithf
-                 (f_ "Malformed log file '%s' at line %d")
-                 (ctxt.srcfs#string_of_filename default_filename)
-                 !line
+                           SetTupleString.add t st,
+                           t :: lst)
+                with Scanf.Scan_failure _ ->
+                  failwith
+                    (Scanf.bscanf scbuf
+                       "%l"
+                       (fun line ->
+                          Printf.sprintf
+                            "Malformed log file '%s' at line %d"
+                            default_filename
+                            line))
            in
-           read_aux (SetTupleString.empty, []))
-    end else begin
+                read_aux acc
+            end
+          else
+            begin
+              close_in chn;
+              List.rev lst
+            end
+        in
+          read_aux (SetTupleString.empty, [])
+      end
+    else
+      begin
       []
     end
 
 
-  let register ~ctxt event data =
-    defer_close
-      (ctxt.srcfs#open_out
-         ~mode:[Open_append; Open_creat; Open_text]
-         ~perm:0o644
-         default_filename)
-      (fun wrtr ->
-         let buf = Buffer.create 13 in
-         Printf.bprintf buf "%S %S\n" event data;
-         wrtr#output buf)
+  let register event data =
+    let chn_out =
+      open_out_gen [Open_append; Open_creat; Open_text] 0o644 default_filename
+    in
+      Printf.fprintf chn_out "%S %S\n" event data;
+      close_out chn_out
 
 
-  let unregister ~ctxt event data =
-    let lst = load ~ctxt () in
-    let buf = Buffer.create 13 in
+  let unregister event data =
+    if Sys.file_exists default_filename then
+      begin
+        let lst =
+          load ()
+        in
+        let chn_out =
+          open_out default_filename
+        in
+        let write_something =
+          ref false
+        in
     List.iter
       (fun (e, d) ->
          if e <> event || d <> data then
-           Printf.bprintf buf "%S %S\n" e d)
+                 begin
+                   write_something := true;
+                   Printf.fprintf chn_out "%S %S\n" e d
+                 end)
       lst;
-    if Buffer.length buf > 0 then
-      defer_close
-        (ctxt.srcfs#open_out default_filename)
-        (fun wrtr -> wrtr#output buf)
-    else
-      ctxt.srcfs#remove default_filename
+          close_out chn_out;
+          if not !write_something then
+            Sys.remove default_filename
+      end
 
 
-  let filter ~ctxt events =
-    let st_events = SetString.of_list events in
+  let filter events =
+    let st_events =
+      List.fold_left
+        (fun st e ->
+           SetString.add e st)
+        SetString.empty
+        events
+    in
     List.filter
       (fun (e, _) -> SetString.mem e st_events)
-      (load ~ctxt ())
+        (load ())
 
 
-  let exists ~ctxt event data =
+  let exists event data =
     List.exists
       (fun v -> (event, data) = v)
-      (load ~ctxt ())
+      (load ())
 end
 
 module BaseBuilt = struct
@@ -4617,24 +4902,27 @@
     "is_"^(to_log_event_file t nm)
 
 
-  let register ~ctxt t nm lst =
-    BaseLog.register ~ctxt (to_log_event_done t nm) "true";
+  let register t nm lst =
+    BaseLog.register
+      (to_log_event_done t nm)
+      "true";
     List.iter
       (fun alt ->
          let registered =
            List.fold_left
              (fun registered fn ->
-                if OASISFileUtil.file_exists_case fn then begin
-                  BaseLog.register ~ctxt
+                if OASISFileUtil.file_exists_case fn then
+                  begin
+                    BaseLog.register
                     (to_log_event_file t nm)
                     (if Filename.is_relative fn then
                        Filename.concat (Sys.getcwd ()) fn
                      else
                        fn);
                   true
-                end else begin
-                  registered
-                end)
+                  end
+                else
+                  registered)
              false
              alt
          in
@@ -4645,40 +4933,56 @@
       lst
 
 
-  let unregister ~ctxt t nm =
+  let unregister t nm =
     List.iter
-      (fun (e, d) -> BaseLog.unregister ~ctxt e d)
-      (BaseLog.filter ~ctxt [to_log_event_file t nm; to_log_event_done t nm])
+      (fun (e, d) ->
+         BaseLog.unregister e d)
+      (BaseLog.filter
+         [to_log_event_file t nm;
+          to_log_event_done t nm])
 
 
-  let fold ~ctxt t nm f acc =
+  let fold t nm f acc =
     List.fold_left
       (fun acc (_, fn) ->
-         if OASISFileUtil.file_exists_case fn then begin
+         if OASISFileUtil.file_exists_case fn then
+           begin
            f acc fn
-         end else begin
+           end
+         else
+           begin
            warning
              (f_ "File '%s' has been marked as built \
                   for %s but doesn't exist")
              fn
              (Printf.sprintf
                 (match t with
-                  | BExec | BExecLib -> (f_ "executable %s")
-                  | BLib -> (f_ "library %s")
-                  | BObj -> (f_ "object %s")
-                  | BDoc -> (f_ "documentation %s"))
+                     | BExec | BExecLib ->
+                         (f_ "executable %s")
+                     | BLib ->
+                         (f_ "library %s")
+                     | BObj ->
+                         (f_ "object %s")
+                     | BDoc ->
+                         (f_ "documentation %s"))
                 nm);
            acc
          end)
       acc
-      (BaseLog.filter ~ctxt [to_log_event_file t nm])
+      (BaseLog.filter
+         [to_log_event_file t nm])
 
 
-  let is_built ~ctxt t nm =
+  let is_built t nm =
     List.fold_left
-      (fun _ (_, d) -> try bool_of_string d with _ -> false)
+      (fun is_built (_, d) ->
+         (try
+            bool_of_string d
+          with _ ->
+            false))
       false
-      (BaseLog.filter ~ctxt [to_log_event_done t nm])
+      (BaseLog.filter
+         [to_log_event_done t nm])
 
 
   let of_executable ffn (cs, bs, exec) =
@@ -4757,7 +5061,7 @@
     OASISExec.run ~ctxt:!BaseContext.default ~quote:false
       (var_expand cmd)
       (List.map
-         var_expand
+         (var_expand ~quoted:true)
          (args @ (Array.to_list extra_args)))
 
 
@@ -4806,12 +5110,12 @@
   open BaseBuilt
 
 
-  let init ~ctxt pkg =
+  let init pkg =
     (* TODO: disambiguate exec vs other variable by adding exec_VARNAME. *)
     (* TODO: provide compile option for library libary_byte_args_VARNAME... *)
     List.iter
       (function
-        | Executable (cs, bs, _) ->
+         | Executable (cs, bs, exec) ->
           if var_choose bs.bs_build then
             var_ignore
               (var_redefine
@@ -4824,7 +5128,10 @@
                  (OASISUtils.varname_of_string cs.cs_name)
                  (fun () ->
                     let fn_opt =
-                      fold ~ctxt BExec cs.cs_name (fun _ fn -> Some fn) None
+                         fold
+                           BExec cs.cs_name
+                           (fun _ fn -> Some fn)
+                           None
                     in
                     match fn_opt with
                     | Some fn -> fn
@@ -4848,10 +5155,11 @@
   open BaseEnv
   open BaseMessage
   open OASISTypes
+  open OASISExpr
   open OASISGettext
 
 
-  let test ~ctxt lst pkg extra_args =
+  let test lst pkg extra_args =
 
     let one_test (failure, n) (test_plugin, cs, test) =
       if var_choose
@@ -4861,11 +5169,15 @@
           ~printer:string_of_bool
           test.test_run then
         begin
-          let () = info (f_ "Running test '%s'") cs.cs_name in
+          let () =
+            info (f_ "Running test '%s'") cs.cs_name
+          in
           let back_cwd =
             match test.test_working_directory with
               | Some dir ->
-                let cwd = Sys.getcwd () in
+                  let cwd =
+                    Sys.getcwd ()
+                  in
                 let chdir d =
                   info (f_ "Changing directory to '%s'") d;
                   Sys.chdir d
@@ -4880,7 +5192,7 @@
             let failure_percent =
               BaseCustom.hook
                 test.test_custom
-                (test_plugin ~ctxt pkg (cs, test))
+                  (test_plugin pkg (cs, test))
                 extra_args
             in
             back_cwd ();
@@ -4897,8 +5209,18 @@
           (failure, n)
         end
     in
-    let failed, n = List.fold_left one_test (0.0, 0) lst in
-    let failure_percent = if n = 0 then 0.0 else failed /. (float_of_int n) in
+    let failed, n =
+      List.fold_left
+        one_test
+        (0.0, 0)
+        lst
+    in
+    let failure_percent =
+      if n = 0 then
+        0.0
+      else
+        failed /. (float_of_int n)
+    in
     let msg =
       Printf.sprintf
         (f_ "Tests had a %.2f%% failure rate")
@@ -4928,7 +5250,7 @@
   open OASISGettext
 
 
-  let doc ~ctxt lst pkg extra_args =
+  let doc lst pkg extra_args =
 
     let one_doc (doc_plugin, cs, doc) =
       if var_choose
@@ -4941,7 +5263,7 @@
           info (f_ "Building documentation '%s'") cs.cs_name;
           BaseCustom.hook
             doc.doc_custom
-            (doc_plugin ~ctxt pkg (cs, doc))
+            (doc_plugin pkg (cs, doc))
             extra_args
         end
     in
@@ -4958,25 +5280,20 @@
 module BaseSetup = struct
 (* # 22 "src/base/BaseSetup.ml" *)
 
-  open OASISContext
   open BaseEnv
   open BaseMessage
   open OASISTypes
+  open OASISSection
   open OASISGettext
   open OASISUtils
 
 
   type std_args_fun =
-    ctxt:OASISContext.t -> package -> string array -> unit
+      package -> string array -> unit
 
 
   type ('a, 'b) section_args_fun =
-    name *
-    (ctxt:OASISContext.t ->
-     package ->
-     (common_section * 'a) ->
-     string array ->
-     'b)
+      name * (package -> (common_section * 'a) -> string array -> 'b)
 
 
   type t =
@@ -5029,48 +5346,65 @@
         action
 
 
-  let configure ~ctxt t args =
+  let configure t args =
     (* Run configure *)
+
+    (* use-bash is an exception. It's already needed to run the
+       pre-configure script. *)
+    let rec f = function
+      | [] ->
+        begin
+          try
+            let x = Sys.getenv "USE_BASH" in
+              OASISHostPath.bash_cmd := (fun () -> x);
+          with
+            _ -> ()
+        end
+      | "--use-bash"::x::_ ->
+          OASISHostPath.bash_cmd := (fun () -> x);
+      | _::tl -> f tl
+    in
+      f (Array.to_list args);
     BaseCustom.hook
       t.package.conf_custom
       (fun () ->
+           OASISHostPath.bash_cmd := BaseStandardVar.bash_cmd;
          (* Reload if preconf has changed it *)
          begin
            try
              unload ();
-             load ~ctxt ();
+             load ();
            with _ ->
              ()
          end;
 
          (* Run plugin's configure *)
-         t.configure ~ctxt t.package args;
+         t.configure t.package args;
 
          (* Dump to allow postconf to change it *)
-         dump ~ctxt ())
+         dump ())
       ();
 
     (* Reload environment *)
     unload ();
-    load ~ctxt ();
+    load ();
 
     (* Save environment *)
     print ();
 
     (* Replace data in file *)
-    BaseFileAB.replace ~ctxt t.package.files_ab
+    BaseFileAB.replace t.package.files_ab
 
 
-  let build ~ctxt t args =
+  let build t args =
     BaseCustom.hook
       t.package.build_custom
-      (t.build ~ctxt t.package)
+      (t.build t.package)
       args
 
 
-  let doc ~ctxt t args =
+  let doc t args =
     BaseDoc.doc
-      ~ctxt
       (join_plugin_sections
          (function
            | Doc (cs, e) ->
@@ -5089,9 +5423,8 @@
       args
 
 
-  let test ~ctxt t args =
+  let test t args =
     BaseTest.test
-      ~ctxt
       (join_plugin_sections
          (function
            | Test (cs, e) ->
@@ -5110,10 +5443,16 @@
       args
 
 
-  let all ~ctxt t args =
-    let rno_doc = ref false in
-    let rno_test = ref false in
-    let arg_rest = ref [] in
+  let all t args =
+    let rno_doc =
+      ref false
+    in
+    let rno_test =
+      ref false
+    in
+    let arg_rest =
+      ref []
+    in
     Arg.parse_argv
       ~current:(ref 0)
       (Array.of_list
@@ -5136,39 +5475,52 @@
       "";
 
     info "Running configure step";
-    configure ~ctxt t (Array.of_list (List.rev !arg_rest));
+      configure t (Array.of_list (List.rev !arg_rest));
 
     info "Running build step";
-    build ~ctxt t [||];
+      build     t [||];
 
     (* Load setup.log dynamic variables *)
-    BaseDynVar.init ~ctxt t.package;
+      BaseDynVar.init t.package;
 
-    if not !rno_doc then begin
+      if not !rno_doc then
+        begin
       info "Running doc step";
-      doc ~ctxt t [||]
-    end else begin
+          doc t [||];
+        end
+      else
+        begin
       info "Skipping doc step"
     end;
-    if not !rno_test then begin
+
+      if not !rno_test then
+        begin
       info "Running test step";
-      test ~ctxt t [||]
-    end else begin
+          test t [||]
+        end
+      else
+        begin
       info "Skipping test step"
     end
 
 
-  let install ~ctxt t args =
-    BaseCustom.hook t.package.install_custom (t.install ~ctxt t.package) args
+  let install t args =
+    BaseCustom.hook
+      t.package.install_custom
+      (t.install t.package)
+      args
 
 
-  let uninstall ~ctxt t args =
-    BaseCustom.hook t.package.uninstall_custom (t.uninstall ~ctxt t.package) args
+  let uninstall t args =
+    BaseCustom.hook
+      t.package.uninstall_custom
+      (t.uninstall t.package)
+      args
 
 
-  let reinstall ~ctxt t args =
-    uninstall ~ctxt t args;
-    install ~ctxt t args
+  let reinstall t args =
+    uninstall t args;
+    install t args
 
 
   let clean, distclean =
@@ -5183,7 +5535,7 @@
             | e -> Printexc.to_string e)
     in
 
-    let generic_clean ~ctxt t cstm mains docs tests args =
+    let generic_clean t cstm mains docs tests args =
       BaseCustom.hook
         ~failsafe:true
         cstm
@@ -5196,27 +5548,40 @@
                    try
                      List.assoc cs.cs_name tests
                    with Not_found ->
-                   fun ~ctxt:_ _ _ _ -> ()
+                        fun _ _ _ -> ()
                  in
-                 failsafe (f ~ctxt t.package (cs, test)) args
+                      failsafe
+                        (f t.package (cs, test))
+                        args
                | Doc (cs, doc) ->
                  let f =
                    try
                      List.assoc cs.cs_name docs
                    with Not_found ->
-                   fun ~ctxt:_ _ _ _ -> ()
+                        fun _ _ _ -> ()
                  in
-                 failsafe (f ~ctxt t.package (cs, doc)) args
-               | Library _ | Object _ | Executable _ | Flag _ | SrcRepo _ -> ())
+                      failsafe
+                        (f t.package (cs, doc))
+                        args
+                | Library _
+                | Object _
+                | Executable _
+                | Flag _
+                | SrcRepo _ ->
+                    ())
              t.package.sections;
            (* Clean whole package *)
-           List.iter (fun f -> failsafe (f ~ctxt t.package) args) mains)
+           List.iter
+             (fun f ->
+                failsafe
+                  (f t.package)
+                  args)
+             mains)
         ()
     in
 
-    let clean ~ctxt t args =
+    let clean t args =
       generic_clean
-        ~ctxt
         t
         t.package.clean_custom
         t.clean
@@ -5225,13 +5590,12 @@
         args
     in
 
-    let distclean ~ctxt t args =
+    let distclean t args =
       (* Call clean *)
-      clean ~ctxt t args;
+      clean t args;
 
       (* Call distclean code *)
       generic_clean
-        ~ctxt
         t
         t.package.distclean_custom
         t.distclean
@@ -5239,21 +5603,26 @@
         t.distclean_test
         args;
 
-      (* Remove generated source files. *)
+      (* Remove generated file *)
       List.iter
         (fun fn ->
-           if ctxt.srcfs#file_exists fn then begin
-             info (f_ "Remove '%s'") (ctxt.srcfs#string_of_filename fn);
-             ctxt.srcfs#remove fn
+           if Sys.file_exists fn then
+             begin
+               info (f_ "Remove '%s'") fn;
+               Sys.remove fn
            end)
-        ([BaseEnv.default_filename; BaseLog.default_filename]
-         @ (List.rev_map BaseFileAB.to_filename t.package.files_ab))
+        (BaseEnv.default_filename
+         ::
+         BaseLog.default_filename
+         ::
+         (List.rev_map BaseFileAB.to_filename t.package.files_ab))
     in
 
     clean, distclean
 
 
-  let version ~ctxt:_ (t: t) _ = print_endline t.oasis_version
+  let version t _ =
+    print_endline t.oasis_version
 
 
   let update_setup_ml, no_update_setup_ml_cli =
@@ -5263,7 +5632,7 @@
      Arg.Clear b,
      s_ " Don't try to update setup.ml, even if _oasis has changed.")
 
-  (* TODO: srcfs *)
+
   let default_oasis_fn = "_oasis"
 
 
@@ -5344,8 +5713,10 @@
               OASISExec.run
                 ~ctxt:!BaseContext.default
                 ~f_exit_code:
-                  (fun n ->
-                     if n <> 0 then
+                  (function
+                     | 0 ->
+                         ()
+                     | n ->
                        failwithf
                          (f_ "Unable to update setup.ml using '%s', \
                               please fix the problem and retry.")
@@ -5390,17 +5761,24 @@
 
 
   let setup t =
-    let catch_exn = ref true in
+    let catch_exn =
+      ref true
+    in
+      try
     let act_ref =
-      ref (fun ~ctxt:_ _ ->
+          ref (fun _ ->
         failwithf
           (f_ "No action defined, run '%s %s -help'")
           Sys.executable_name
           Sys.argv.(0))
 
     in
-    let extra_args_ref = ref [] in
-    let allow_empty_env_ref = ref false in
+        let extra_args_ref =
+          ref []
+        in
+        let allow_empty_env_ref =
+          ref false
+        in
     let arg_handle ?(allow_empty_env=false) act =
       Arg.Tuple
         [
@@ -5411,8 +5790,7 @@
                act_ref := act);
         ]
     in
-    try
-      let () =
+
         Arg.parse
           (Arg.align
              ([
@@ -5456,214 +5834,78 @@
                s_ "[options*] Clean files generated by a build.";
 
                "-distclean",
-               arg_handle ~allow_empty_env:true distclean,
-               s_ "[options*] Clean files generated by a build and configure.";
-
-               "-version",
-               arg_handle ~allow_empty_env:true version,
-               s_ " Display version of OASIS used to generate this setup.ml.";
-
-               "-no-catch-exn",
-               Arg.Clear catch_exn,
-               s_ " Don't catch exception, useful for debugging.";
-             ]
-              @
-                (if t.setup_update then
-                   [no_update_setup_ml_cli]
-                 else
-                   [])
-              @ (BaseContext.args ())))
-          (failwithf (f_ "Don't know what to do with '%s'"))
-          (s_ "Setup and run build process current package\n")
-      in
-
-      (* Instantiate the context. *)
-      let ctxt = !BaseContext.default in
-
-      (* Build initial environment *)
-      load ~ctxt ~allow_empty:!allow_empty_env_ref ();
-
-      (** Initialize flags *)
-      List.iter
-        (function
-          | Flag (cs, {flag_description = hlp;
-                       flag_default = choices}) ->
-            begin
-              let apply ?short_desc () =
-                var_ignore
-                  (var_define
-                     ~cli:CLIEnable
-                     ?short_desc
-                     (OASISUtils.varname_of_string cs.cs_name)
-                     (fun () ->
-                        string_of_bool
-                          (var_choose
-                             ~name:(Printf.sprintf
-                                 (f_ "default value of flag %s")
-                                 cs.cs_name)
-                             ~printer:string_of_bool
-                             choices)))
-              in
-              match hlp with
-              | Some hlp -> apply ~short_desc:(fun () -> hlp) ()
-              | None -> apply ()
-            end
-          | _ ->
-            ())
-        t.package.sections;
-
-      BaseStandardVar.init t.package;
-
-      BaseDynVar.init ~ctxt t.package;
-
-      if not (t.setup_update && update_setup_ml t) then
-        !act_ref ~ctxt t (Array.of_list (List.rev !extra_args_ref))
-
-    with e when !catch_exn ->
-      error "%s" (Printexc.to_string e);
-      exit 1
-
-
-end
-
-module BaseCompat = struct
-(* # 22 "src/base/BaseCompat.ml" *)
-
-  (** Compatibility layer to provide a stable API inside setup.ml.
-      This layer allows OASIS to change in between minor versions
-      (e.g. 0.4.6 -> 0.4.7) but still provides a stable API inside setup.ml. This
-      enables to write functions that manipulate setup_t inside setup.ml. See
-      deps.ml for an example.
-
-      The module opened by default will depend on the version of the _oasis. E.g.
-      if we have "OASISFormat: 0.3", the module Compat_0_3 will be opened and
-      the function Compat_0_3 will be called. If setup.ml is generated with the
-      -nocompat, no module will be opened.
-
-      @author Sylvain Le Gall
-    *)
-
-  module Compat_0_4 =
-  struct
-    let rctxt = ref !BaseContext.default
-
-    module BaseSetup =
-    struct
-      module Original = BaseSetup
-
-      open OASISTypes
-
-      type std_args_fun = package -> string array -> unit
-      type ('a, 'b) section_args_fun =
-        name * (package -> (common_section * 'a) -> string array -> 'b)
-      type t =
-        {
-          configure:        std_args_fun;
-          build:            std_args_fun;
-          doc:              ((doc, unit)  section_args_fun) list;
-          test:             ((test, float) section_args_fun) list;
-          install:          std_args_fun;
-          uninstall:        std_args_fun;
-          clean:            std_args_fun list;
-          clean_doc:        (doc, unit) section_args_fun list;
-          clean_test:       (test, unit) section_args_fun list;
-          distclean:        std_args_fun list;
-          distclean_doc:    (doc, unit) section_args_fun list;
-          distclean_test:   (test, unit) section_args_fun list;
-          package:          package;
-          oasis_fn:         string option;
-          oasis_version:    string;
-          oasis_digest:     Digest.t option;
-          oasis_exec:       string option;
-          oasis_setup_args: string list;
-          setup_update:     bool;
-        }
-
-      let setup t =
-        let mk_std_args_fun f =
-          fun ~ctxt pkg args -> rctxt := ctxt; f pkg args
-        in
-        let mk_section_args_fun l =
-          List.map
-            (fun (nm, f) ->
-               nm,
-               (fun ~ctxt pkg sct args ->
-                  rctxt := ctxt;
-                  f pkg sct args))
-            l
-        in
-        let t' =
-          {
-            Original.
-            configure =        mk_std_args_fun t.configure;
-            build =            mk_std_args_fun t.build;
-            doc =              mk_section_args_fun t.doc;
-            test =             mk_section_args_fun t.test;
-            install =          mk_std_args_fun t.install;
-            uninstall =        mk_std_args_fun t.uninstall;
-            clean =            List.map mk_std_args_fun t.clean;
-            clean_doc =        mk_section_args_fun t.clean_doc;
-            clean_test =       mk_section_args_fun t.clean_test;
-            distclean =        List.map mk_std_args_fun t.distclean;
-            distclean_doc =    mk_section_args_fun t.distclean_doc;
-            distclean_test =   mk_section_args_fun t.distclean_test;
-
-            package =          t.package;
-            oasis_fn =         t.oasis_fn;
-            oasis_version =    t.oasis_version;
-            oasis_digest =     t.oasis_digest;
-            oasis_exec =       t.oasis_exec;
-            oasis_setup_args = t.oasis_setup_args;
-            setup_update =     t.setup_update;
-          }
-        in
-        Original.setup t'
+                 arg_handle ~allow_empty_env:true distclean,
+                 s_ "[options*] Clean files generated by a build and configure.";
 
-    end
+                 "-version",
+                 arg_handle ~allow_empty_env:true version,
+                 s_ " Display version of OASIS used to generate this setup.ml.";
 
-    let adapt_setup_t setup_t =
-      let module O = BaseSetup.Original in
-      let mk_std_args_fun f = fun pkg args -> f ~ctxt:!rctxt pkg args in
-      let mk_section_args_fun l =
-        List.map
-          (fun (nm, f) -> nm, (fun pkg sct args -> f ~ctxt:!rctxt pkg sct args))
-          l
+                 "-no-catch-exn",
+                 Arg.Clear catch_exn,
+                 s_ " Don't catch exception, useful for debugging.";
+               ]
+               @
+                (if t.setup_update then
+                   [no_update_setup_ml_cli]
+                 else
+                   [])
+               @ (BaseContext.args ())))
+            (failwithf (f_ "Don't know what to do with '%s'"))
+            (s_ "Setup and run build process current package\n");
+
+          (* Build initial environment *)
+          load ~allow_empty:!allow_empty_env_ref ();
+
+          (** Initialize flags *)
+          List.iter
+            (function
+               | Flag (cs, {flag_description = hlp;
+                            flag_default = choices}) ->
+                   begin
+                     let apply ?short_desc () =
+                       var_ignore
+                         (var_define
+                            ~cli:CLIEnable
+                            ?short_desc
+                            (OASISUtils.varname_of_string cs.cs_name)
+                            (fun () ->
+                               string_of_bool
+                                 (var_choose
+                                    ~name:(Printf.sprintf
+                                             (f_ "default value of flag %s")
+                                             cs.cs_name)
+                                    ~printer:string_of_bool
+                                             choices)))
       in
-      {
-        BaseSetup.
-        configure =        mk_std_args_fun setup_t.O.configure;
-        build =            mk_std_args_fun setup_t.O.build;
-        doc =              mk_section_args_fun setup_t.O.doc;
-        test =             mk_section_args_fun setup_t.O.test;
-        install =          mk_std_args_fun setup_t.O.install;
-        uninstall =        mk_std_args_fun setup_t.O.uninstall;
-        clean =            List.map mk_std_args_fun setup_t.O.clean;
-        clean_doc =        mk_section_args_fun setup_t.O.clean_doc;
-        clean_test =       mk_section_args_fun setup_t.O.clean_test;
-        distclean =        List.map mk_std_args_fun setup_t.O.distclean;
-        distclean_doc =    mk_section_args_fun setup_t.O.distclean_doc;
-        distclean_test =   mk_section_args_fun setup_t.O.distclean_test;
-
-        package =          setup_t.O.package;
-        oasis_fn =         setup_t.O.oasis_fn;
-        oasis_version =    setup_t.O.oasis_version;
-        oasis_digest =     setup_t.O.oasis_digest;
-        oasis_exec =       setup_t.O.oasis_exec;
-        oasis_setup_args = setup_t.O.oasis_setup_args;
-        setup_update =     setup_t.O.setup_update;
-      }
+                       match hlp with
+                         | Some hlp ->
+                             apply ~short_desc:(fun () -> hlp) ()
+                         | None ->
+                             apply ()
   end
+               | _ ->
+                   ())
+            t.package.sections;
 
+          BaseStandardVar.init t.package;
+
+          BaseDynVar.init t.package;
+
+          if t.setup_update && update_setup_ml t then
+            ()
+          else
+            !act_ref t (Array.of_list (List.rev !extra_args_ref))
+
+      with e when !catch_exn ->
+        error "%s" (Printexc.to_string e);
+        exit 1
 
-  module Compat_0_3 =
-  struct
-    include Compat_0_4
-  end
 
 end
 
 
-# 5668 "setup.ml"
+# 5910 "setup.ml"
 module InternalConfigurePlugin = struct
 (* # 22 "src/plugins/internal/InternalConfigurePlugin.ml" *)
 
@@ -5681,9 +5923,9 @@
 
 
   (** Configure build using provided series of check to be done
-      and then output corresponding file.
+    * and then output corresponding file.
   *)
-  let configure ~ctxt:_ pkg argv =
+  let configure pkg argv =
     let var_ignore_eval var = let _s: string = var () in () in
     let errors = ref SetString.empty in
     let buff = Buffer.create 13 in
@@ -5717,8 +5959,8 @@
             (* Check that matching tool is built *)
             List.iter
               (function
-                | Executable ({cs_name = nm2; _},
-                              {bs_build = build; _},
+                    | Executable ({cs_name = nm2},
+                                  {bs_build = build},
                     _) when nm1 = nm2 ->
                   if not (var_choose build) then
                     add_errors
@@ -5773,8 +6015,8 @@
                 (* Check that matching library is built *)
                 List.iter
                   (function
-                    | Library ({cs_name = nm2; _},
-                               {bs_build = build; _},
+                        | Library ({cs_name = nm2},
+                                   {bs_build = build},
                         _) when nm1 = nm2 ->
                       if not (var_choose build) then
                         add_errors
@@ -5838,7 +6080,7 @@
     begin
       let ocaml_ge4 =
         OASISVersion.version_compare
-          (OASISVersion.version_of_string (BaseStandardVar.ocaml_version ()))
+          (OASISVersion.version_of_string (BaseStandardVar.ocaml_version()))
           (OASISVersion.version_of_string "4.0.0") >= 0 in
       if ocaml_ge4 then
         let findlib_lt132 =
@@ -5877,7 +6119,7 @@
       pkg.sections;
 
     (* Check if we need native dynlink (presence of libraries that compile to
-       native)
+     * native)
     *)
     begin
       let has_cmxa =
@@ -5922,8 +6164,6 @@
     *)
 
 
-  (* TODO: rewrite this module with OASISFileSystem. *)
-
   open BaseEnv
   open BaseStandardVar
   open BaseMessage
@@ -5933,22 +6173,47 @@
   open OASISUtils
 
 
-  let exec_hook = ref (fun (cs, bs, exec) -> cs, bs, exec)
-  let lib_hook  = ref (fun (cs, bs, dn, lib) -> cs, bs, dn, lib, [])
-  let obj_hook  = ref (fun (cs, bs, dn, obj) -> cs, bs, dn, obj, [])
-  let doc_hook  = ref (fun (cs, doc) -> cs, doc)
-
-  let install_file_ev    = "install-file"
-  let install_dir_ev     = "install-dir"
-  let install_findlib_ev = "install-findlib"
+  let exec_hook =
+    ref (fun (cs, bs, exec) -> cs, bs, exec)
+
+
+  let lib_hook =
+    ref (fun (cs, bs, lib) -> cs, bs, lib, [])
+
 
+  let obj_hook =
+    ref (fun (cs, bs, obj) -> cs, bs, obj, [])
 
-  (* TODO: this can be more generic and used elsewhere. *)
-  let win32_max_command_line_length = 8000
+
+  let doc_hook =
+    ref (fun (cs, doc) -> cs, doc)
+
+
+  let install_file_ev =
+    "install-file"
+
+
+  let install_dir_ev =
+    "install-dir"
+
+
+  let install_findlib_ev =
+    "install-findlib"
 
 
   let split_install_command ocamlfind findlib_name meta files =
     if Sys.os_type = "Win32" then
+      let f s =
+        OASISHostPath.quote ( OASISHostPath.of_unix s )
+      in
+      let files = List.map f files in
+      let meta = f meta  in
+      let win32_max_command_line_length =
+        if OASISHostPath.use_bash () = false then
+          8000
+        else
+          30000
+      in
       (* Arguments for the first command: *)
       let first_args = ["install"; findlib_name; meta] in
       (* Arguments for remaining commands: *)
@@ -6012,7 +6277,7 @@
       ["install" :: findlib_name :: meta :: files]
 
 
-  let install =
+  let install pkg argv =
 
     let in_destdir =
       try
@@ -6027,9 +6292,9 @@
         fun fn -> fn
     in
 
-    let install_file ~ctxt ?(prepend_destdir=true) ?tgt_fn src_file envdir =
+    let install_file ?tgt_fn src_file envdir =
       let tgt_dir =
-        if prepend_destdir then in_destdir (envdir ()) else envdir ()
+        in_destdir (envdir ())
       in
       let tgt_file =
         Filename.concat
@@ -6042,48 +6307,20 @@
       in
         (* Create target directory if needed *)
         OASISFileUtil.mkdir_parent
-          ~ctxt
+          ~ctxt:!BaseContext.default
           (fun dn ->
              info (f_ "Creating directory '%s'") dn;
-             BaseLog.register ~ctxt install_dir_ev dn)
-          (Filename.dirname tgt_file);
+             BaseLog.register install_dir_ev dn)
+          tgt_dir;
 
         (* Really install files *)
         info (f_ "Copying file '%s' to '%s'") src_file tgt_file;
-        OASISFileUtil.cp ~ctxt src_file tgt_file;
-        BaseLog.register ~ctxt install_file_ev tgt_file
-    in
-
-    (* Install the files for a library. *)
-
-    let install_lib_files ~ctxt findlib_name files =
-      let findlib_dir =
-        let dn =
-          let findlib_destdir =
-            OASISExec.run_read_one_line ~ctxt (ocamlfind ())
-              ["printconf" ; "destdir"]
-          in
-          Filename.concat findlib_destdir findlib_name
-        in
-        fun () -> dn
-      in
-      let () =
-        if not (OASISFileUtil.file_exists_case (findlib_dir ())) then
-          failwithf
-            (f_ "Directory '%s' doesn't exist for findlib library %s")
-            (findlib_dir ()) findlib_name
-      in
-      let f dir file =
-        let basename = Filename.basename file in
-        let tgt_fn = Filename.concat dir basename in
-        (* Destdir is already include in printconf. *)
-        install_file ~ctxt ~prepend_destdir:false ~tgt_fn file findlib_dir
-      in
-      List.iter (fun (dir, files) -> List.iter (f dir) files) files ;
+        OASISFileUtil.cp ~ctxt:!BaseContext.default src_file tgt_file;
+        BaseLog.register install_file_ev tgt_file
     in
 
     (* Install data into defined directory *)
-    let install_data ~ctxt srcdir lst tgtdir =
+    let install_data srcdir lst tgtdir =
       let tgtdir =
         OASISHostPath.of_unix (var_expand tgtdir)
       in
@@ -6100,7 +6337,7 @@
                    src;
                List.iter
                  (fun fn ->
-                    install_file ~ctxt
+                    install_file
                       fn
                       (fun () ->
                          match tgt_opt with
@@ -6124,97 +6361,64 @@
     in
 
     (** Install all libraries *)
-    let install_libs ~ctxt pkg =
+    let install_libs pkg =
 
-      let find_first_existing_files_in_path bs lst =
-        let path = OASISHostPath.of_unix bs.bs_path in
-        List.find
-          OASISFileUtil.file_exists_case
-          (List.map (Filename.concat path) lst)
+      let files_of_library (f_data, acc) data_lib =
+        let cs, bs, lib, lib_extra =
+          !lib_hook data_lib
+        in
+          if var_choose bs.bs_install &&
+             BaseBuilt.is_built BaseBuilt.BLib cs.cs_name then
+            begin
+              let acc =
+                (* Start with acc + lib_extra *)
+                List.rev_append lib_extra acc
+              in
+              let acc =
+                (* Add uncompiled header from the source tree *)
+                let path =
+                  OASISHostPath.of_unix bs.bs_path
       in
-
-      let files_of_modules new_files typ cs bs modules =
         List.fold_left
-          (fun acc modul ->
+                    begin fun acc modul ->
              begin
                try
-                 (* Add uncompiled header from the source tree *)
-                 [find_first_existing_files_in_path
-                    bs (make_fnames modul [".mli"; ".ml"])]
+                          [List.find
+                            OASISFileUtil.file_exists_case
+                            (List.map
+                               (Filename.concat path)
+                               (make_fnames modul [".mli"; ".ml"]))]
                with Not_found ->
                  warning
                    (f_ "Cannot find source header for module %s \
-                        in %s %s")
-                   typ modul cs.cs_name;
+                                 in library %s")
+                            modul cs.cs_name;
                  []
              end
              @
-             List.fold_left
-               (fun acc fn ->
-                  try
-                    find_first_existing_files_in_path bs [fn] :: acc
-                  with Not_found ->
-                    acc)
-               acc (make_fnames modul [".annot";".cmti";".cmt"]))
-          new_files
-          modules
-      in
-
-      let files_of_build_section (f_data, new_files) typ cs bs =
-        let extra_files =
-          List.map
-            (fun fn ->
-               try
-                 find_first_existing_files_in_path bs [fn]
-               with Not_found ->
-                 failwithf
-                   (f_ "Cannot find extra findlib file %S in %s %s ")
-                   fn
-                   typ
-                   cs.cs_name)
-            bs.bs_findlib_extra_files
-        in
-        let f_data () =
-          (* Install data associated with the library *)
-          install_data
-            ~ctxt
-            bs.bs_path
-            bs.bs_data_files
-            (Filename.concat
-               (datarootdir ())
-               pkg.name);
-          f_data ()
-        in
-        f_data, new_files @ extra_files
+                      List.filter
+                        OASISFileUtil.file_exists_case
+                        (List.map
+                           (Filename.concat path)
+                           (make_fnames modul [".annot";".cmti";".cmt"]))
+                      @ acc
+                    end
+                    acc
+                    lib.lib_modules
       in
 
-      let files_of_library (f_data, acc) data_lib =
-        let cs, bs, lib, dn, lib_extra = !lib_hook data_lib in
-        if var_choose bs.bs_install &&
-           BaseBuilt.is_built ~ctxt BaseBuilt.BLib cs.cs_name then begin
-          (* Start with lib_extra *)
-          let new_files = lib_extra in
-          let new_files =
-            files_of_modules new_files "library" cs bs lib.lib_modules
-          in
-          let f_data, new_files =
-            files_of_build_section (f_data, new_files) "library" cs bs
-          in
-          let new_files =
+              let acc =
             (* Get generated files *)
             BaseBuilt.fold
-              ~ctxt
               BaseBuilt.BLib
               cs.cs_name
               (fun acc fn -> fn :: acc)
-              new_files
+                 acc
           in
-          let acc = (dn, new_files) :: acc in
 
           let f_data () =
             (* Install data associated with the library *)
             install_data
-              ~ctxt
               bs.bs_path
               bs.bs_data_files
               (Filename.concat
@@ -6224,46 +6428,82 @@
           in
 
           (f_data, acc)
-        end else begin
+            end
+           else
+            begin
           (f_data, acc)
         end
       and files_of_object (f_data, acc) data_obj =
-        let cs, bs, obj, dn, obj_extra = !obj_hook data_obj in
+        let cs, bs, obj, obj_extra =
+          !obj_hook data_obj
+        in
         if var_choose bs.bs_install &&
-           BaseBuilt.is_built ~ctxt BaseBuilt.BObj cs.cs_name then begin
-          (* Start with obj_extra *)
-          let new_files = obj_extra in
-          let new_files =
-            files_of_modules new_files "object" cs bs obj.obj_modules
+             BaseBuilt.is_built BaseBuilt.BObj cs.cs_name then
+            begin
+              let acc =
+                (* Start with acc + obj_extra *)
+                List.rev_append obj_extra acc
           in
-          let f_data, new_files =
-            files_of_build_section (f_data, new_files) "object" cs bs
+              let acc =
+                (* Add uncompiled header from the source tree *)
+                let path =
+                  OASISHostPath.of_unix bs.bs_path
+                in
+                  List.fold_left
+                    begin fun acc modul ->
+                      begin
+                        try
+                          [List.find
+                             OASISFileUtil.file_exists_case
+                             (List.map
+                                (Filename.concat path)
+                                (make_fnames modul [".mli"; ".ml"]))]
+                        with Not_found ->
+                          warning
+                            (f_ "Cannot find source header for module %s \
+                                 in object %s")
+                            modul cs.cs_name;
+                          []
+                      end
+                      @
+                      List.filter
+                        OASISFileUtil.file_exists_case
+                        (List.map
+                           (Filename.concat path)
+                           (make_fnames modul [".annot";".cmti";".cmt"]))
+                      @ acc
+                    end
+                    acc
+                    obj.obj_modules
           in
 
-          let new_files =
+              let acc =
             (* Get generated files *)
             BaseBuilt.fold
-              ~ctxt
               BaseBuilt.BObj
               cs.cs_name
               (fun acc fn -> fn :: acc)
-              new_files
+                 acc
           in
-          let acc = (dn, new_files) :: acc in
 
           let f_data () =
             (* Install data associated with the object *)
             install_data
-              ~ctxt
               bs.bs_path
               bs.bs_data_files
-              (Filename.concat (datarootdir ()) pkg.name);
+                  (Filename.concat
+                     (datarootdir ())
+                     pkg.name);
             f_data ()
           in
+
           (f_data, acc)
-        end else begin
+            end
+           else
+            begin
           (f_data, acc)
         end
+
       in
 
       (* Install one group of library *)
@@ -6274,10 +6514,10 @@
             match grp with
               | Container (_, children) ->
                   data_and_files, children
-              | Package (_, cs, bs, `Library lib, dn, children) ->
-                  files_of_library data_and_files (cs, bs, lib, dn), children
-              | Package (_, cs, bs, `Object obj, dn, children) ->
-                  files_of_object data_and_files (cs, bs, obj, dn), children
+              | Package (_, cs, bs, `Library lib, children) ->
+                  files_of_library data_and_files (cs, bs, lib), children
+              | Package (_, cs, bs, `Object obj, children) ->
+                  files_of_object data_and_files (cs, bs, obj), children
           in
             List.fold_left
               install_group_lib_aux
@@ -6286,23 +6526,37 @@
         in
 
         (* Findlib name of the root library *)
-        let findlib_name = findlib_of_group grp in
+        let findlib_name =
+          findlib_of_group grp
+        in
 
         (* Determine root library *)
-        let root_lib = root_of_group grp in
+        let root_lib =
+          root_of_group grp
+        in
 
         (* All files to install for this library *)
-        let f_data, files = install_group_lib_aux (ignore, []) grp in
+        let f_data, files =
+          install_group_lib_aux (ignore, []) grp
+        in
 
           (* Really install, if there is something to install *)
-        if files = [] then begin
+          if files = [] then
+            begin
           warning
-            (f_ "Nothing to install for findlib library '%s'") findlib_name
-        end else begin
+                (f_ "Nothing to install for findlib library '%s'")
+                findlib_name
+            end
+          else
+            begin
           let meta =
             (* Search META file *)
-            let _, bs, _ = root_lib in
-            let res = Filename.concat bs.bs_path "META" in
+                let _, bs, _ =
+                  root_lib
+                in
+                let res =
+                  Filename.concat bs.bs_path "META"
+                in
             if not (OASISFileUtil.file_exists_case res) then
               failwithf
                 (f_ "Cannot find file '%s' for findlib library %s")
@@ -6314,42 +6568,45 @@
             (* Make filename shorter to avoid hitting command max line length
              * too early, esp. on Windows.
             *)
-            (* TODO: move to OASISHostPath as make_relative. *)
             let remove_prefix p n =
               let plen = String.length p in
               let nlen = String.length n in
-              if plen <= nlen && String.sub n 0 plen = p then begin
-                let fn_sep = if Sys.os_type = "Win32" then '\\' else '/' in
-                let cutpoint =
-                  plen +
-                  (if plen < nlen && n.[plen] = fn_sep then 1 else 0)
+                    if plen <= nlen && String.sub n 0 plen = p then
+                      begin
+                        let fn_sep =
+                          if Sys.os_type = "Win32" then
+                            '\\'
+                          else
+                            '/'
+                        in
+                        let cutpoint = plen +
+                          (if plen < nlen && n.[plen] = fn_sep then
+                             1
+                           else
+                             0)
                 in
                 String.sub n cutpoint (nlen - cutpoint)
-              end else begin
-                n
               end
+                    else
+                      n
             in
-            List.map
-              (fun (dir, fn) ->
-                 (dir, List.map (remove_prefix (Sys.getcwd ())) fn))
-              files
+                  List.map (remove_prefix (Sys.getcwd ())) files
           in
+                info
+                  (f_ "Installing findlib library '%s'")
+                  findlib_name;
           let ocamlfind = ocamlfind () in
-          let nodir_files, dir_files =
-            List.fold_left
-              (fun (nodir, dir) (dn, lst) ->
-                 match dn with
-                 | Some dn -> nodir, (dn, lst) :: dir
-                 | None -> lst @ nodir, dir)
-              ([], [])
-              (List.rev files)
+                let commands =
+                  split_install_command
+                    ocamlfind
+                    findlib_name
+                    meta
+                    files
           in
-          info (f_ "Installing findlib library '%s'") findlib_name;
           List.iter
-            (OASISExec.run ~ctxt ocamlfind)
-            (split_install_command ocamlfind findlib_name meta nodir_files);
-          install_lib_files ~ctxt findlib_name dir_files;
-          BaseLog.register ~ctxt install_findlib_ev findlib_name
+                  (OASISExec.run ~ctxt:!BaseContext.default ocamlfind)
+                  commands;
+                BaseLog.register install_findlib_ev findlib_name
         end;
 
         (* Install data files *)
@@ -6354,62 +6611,84 @@
 
         (* Install data files *)
         f_data ();
+
       in
 
-      let group_libs, _, _ = findlib_mapping pkg in
+      let group_libs, _, _ =
+        findlib_mapping pkg
+      in
 
         (* We install libraries in groups *)
         List.iter install_group_lib group_libs
     in
 
-    let install_execs ~ctxt pkg =
+    let install_execs pkg =
       let install_exec data_exec =
-        let cs, bs, _ = !exec_hook data_exec in
+        let cs, bs, exec =
+          !exec_hook data_exec
+        in
         if var_choose bs.bs_install &&
-           BaseBuilt.is_built ~ctxt BaseBuilt.BExec cs.cs_name then begin
-          let exec_libdir () = Filename.concat (libdir ()) pkg.name in
+             BaseBuilt.is_built BaseBuilt.BExec cs.cs_name then
+            begin
+              let exec_libdir () =
+                Filename.concat
+                  (libdir ())
+                  pkg.name
+              in
           BaseBuilt.fold
-            ~ctxt
             BaseBuilt.BExec
             cs.cs_name
             (fun () fn ->
-               install_file ~ctxt
+                     install_file
                  ~tgt_fn:(cs.cs_name ^ ext_program ())
                  fn
                  bindir)
             ();
           BaseBuilt.fold
-            ~ctxt
             BaseBuilt.BExecLib
             cs.cs_name
-            (fun () fn -> install_file ~ctxt fn exec_libdir)
+                  (fun () fn ->
+                     install_file
+                       fn
+                       exec_libdir)
             ();
-          install_data ~ctxt
+                install_data
             bs.bs_path
             bs.bs_data_files
-            (Filename.concat (datarootdir ()) pkg.name)
+                  (Filename.concat
+                     (datarootdir ())
+                     pkg.name)
         end
       in
       List.iter
         (function
-          | Executable (cs, bs, exec)-> install_exec (cs, bs, exec)
-          | _ -> ())
+             | Executable (cs, bs, exec)->
+                 install_exec (cs, bs, exec)
+             | _ ->
+                 ())
           pkg.sections
     in
 
-    let install_docs ~ctxt pkg =
+    let install_docs pkg =
       let install_doc data =
-        let cs, doc = !doc_hook data in
+        let cs, doc =
+          !doc_hook data
+        in
         if var_choose doc.doc_install &&
-           BaseBuilt.is_built ~ctxt BaseBuilt.BDoc cs.cs_name then begin
-          let tgt_dir = OASISHostPath.of_unix (var_expand doc.doc_install_dir) in
+             BaseBuilt.is_built BaseBuilt.BDoc cs.cs_name then
+            begin
+              let tgt_dir =
+                OASISHostPath.of_unix (var_expand doc.doc_install_dir)
+              in
           BaseBuilt.fold
-            ~ctxt
             BaseBuilt.BDoc
             cs.cs_name
-            (fun () fn -> install_file ~ctxt fn (fun () -> tgt_dir))
+                  (fun () fn ->
+                     install_file
+                       fn
+                       (fun () -> tgt_dir))
             ();
-          install_data ~ctxt
+                install_data
             Filename.current_dir_name
             doc.doc_data_files
             doc.doc_install_dir
@@ -6417,59 +6696,88 @@
       in
       List.iter
         (function
-          | Doc (cs, doc) -> install_doc (cs, doc)
-          | _ -> ())
+             | Doc (cs, doc) ->
+                 install_doc (cs, doc)
+             | _ ->
+                 ())
         pkg.sections
     in
-    fun ~ctxt pkg _ ->
-      install_libs ~ctxt pkg;
-      install_execs ~ctxt pkg;
-      install_docs ~ctxt pkg
+
+      install_libs  pkg;
+      install_execs pkg;
+      install_docs  pkg
 
 
   (* Uninstall already installed data *)
-  let uninstall ~ctxt _ _ =
-    let uninstall_aux (ev, data) =
-      if ev = install_file_ev then begin
-        if OASISFileUtil.file_exists_case data then begin
-          info (f_ "Removing file '%s'") data;
+  let uninstall _ argv =
+    List.iter
+      (fun (ev, data) ->
+         if ev = install_file_ev then
+           begin
+             if OASISFileUtil.file_exists_case data then
+               begin
+                 info
+                   (f_ "Removing file '%s'")
+                   data;
           Sys.remove data
-        end else begin
-          warning (f_ "File '%s' doesn't exist anymore") data
         end
-      end else if ev = install_dir_ev then begin
-        if Sys.file_exists data && Sys.is_directory data then begin
-          if Sys.readdir data = [||] then begin
-            info (f_ "Removing directory '%s'") data;
-            OASISFileUtil.rmdir ~ctxt data
-          end else begin
+             else
+               begin
+                 warning
+                   (f_ "File '%s' doesn't exist anymore")
+                   data
+               end
+           end
+         else if ev = install_dir_ev then
+           begin
+             if Sys.file_exists data && Sys.is_directory data then
+               begin
+                 if Sys.readdir data = [||] then
+                   begin
+                     info
+                       (f_ "Removing directory '%s'")
+                       data;
+                     OASISFileUtil.rmdir ~ctxt:!BaseContext.default data
+                   end
+                 else
+                   begin
+                     warning
+                       (f_ "Directory '%s' is not empty (%s)")
+                       data
+                       (String.concat
+                          ", "
+                          (Array.to_list
+                             (Sys.readdir data)))
+                   end
+               end
+             else
+               begin
             warning
-              (f_ "Directory '%s' is not empty (%s)")
+                   (f_ "Directory '%s' doesn't exist anymore")
               data
-              (String.concat ", " (Array.to_list (Sys.readdir data)))
           end
-        end else begin
-          warning (f_ "Directory '%s' doesn't exist anymore") data
         end
-      end else if ev = install_findlib_ev then begin
+         else if ev = install_findlib_ev then
+           begin
         info (f_ "Removing findlib library '%s'") data;
-        OASISExec.run ~ctxt (ocamlfind ()) ["remove"; data]
-      end else begin
+             OASISExec.run ~ctxt:!BaseContext.default
+               (ocamlfind ()) ["remove"; data]
+           end
+         else
         failwithf (f_ "Unknown log event '%s'") ev;
-      end;
-      BaseLog.unregister ~ctxt ev data
-    in
+         BaseLog.unregister ev data)
     (* We process event in reverse order *)
-    List.iter uninstall_aux
       (List.rev
-         (BaseLog.filter ~ctxt [install_file_ev; install_dir_ev]));
-    List.iter uninstall_aux
-      (List.rev (BaseLog.filter ~ctxt [install_findlib_ev]))
+         (BaseLog.filter
+            [install_file_ev;
+             install_dir_ev;
+             install_findlib_ev]))
+
 
 end
 
 
-# 6474 "setup.ml"
+# 6782 "setup.ml"
 module OCamlbuildCommon = struct
 (* # 22 "src/plugins/ocamlbuild/OCamlbuildCommon.ml" *)
 
@@ -6506,16 +6816,11 @@
             "-classic-display";
             "-no-log";
             "-no-links";
-          ]
-        else
-          [];
-
-        if OASISVersion.comparator_apply
-            (OASISVersion.version_of_string (ocaml_version ()))
-            (OASISVersion.VLesser (OASISVersion.version_of_string "3.11.1")) then
-          [
-            "-install-lib-dir";
-            (Filename.concat (standard_library ()) "ocamlbuild")
+            (* Fix not longer necassary since at least OCaml 3.11, see #4379.
+               In the future, it's the wrong location, because of the split of
+               ocamlbuild from the main distribution *)
+            (* "-install-lib-dir";
+               (OASISHostPath.quote (OASISHostPath.of_unix (Filename.concat (standard_library ()) "ocamlbuild"))) *)
           ]
         else
           [];
@@ -6550,32 +6855,35 @@
 
 
   (** Run 'ocamlbuild -clean' if not already done *)
-  let run_clean ~ctxt extra_argv =
+  let run_clean extra_argv =
     let extra_cli =
       String.concat " " (Array.to_list extra_argv)
     in
     (* Run if never called with these args *)
-    if not (BaseLog.exists ~ctxt ocamlbuild_clean_ev extra_cli) then
+      if not (BaseLog.exists ocamlbuild_clean_ev extra_cli) then
       begin
-        OASISExec.run ~ctxt (ocamlbuild ()) (fix_args ["-clean"] extra_argv);
-        BaseLog.register ~ctxt ocamlbuild_clean_ev extra_cli;
+          OASISExec.run ~ctxt:!BaseContext.default
+            (ocamlbuild ()) (fix_args ["-clean"] extra_argv);
+          BaseLog.register ocamlbuild_clean_ev extra_cli;
         at_exit
           (fun () ->
              try
-               BaseLog.unregister ~ctxt ocamlbuild_clean_ev extra_cli
-             with _ -> ())
+                 BaseLog.unregister ocamlbuild_clean_ev extra_cli
+               with _ ->
+                 ())
       end
 
 
   (** Run ocamlbuild, unregister all clean events *)
-  let run_ocamlbuild ~ctxt args extra_argv =
+  let run_ocamlbuild args extra_argv =
     (* TODO: enforce that target in args must be UNIX encoded i.e. toto/index.html
     *)
-    OASISExec.run ~ctxt (ocamlbuild ()) (fix_args args extra_argv);
+    OASISExec.run ~ctxt:!BaseContext.default
+      (ocamlbuild ()) (fix_args args extra_argv);
     (* Remove any clean event, we must run it again *)
     List.iter
-      (fun (e, d) -> BaseLog.unregister ~ctxt e d)
-      (BaseLog.filter ~ctxt [ocamlbuild_clean_ev])
+      (fun (e, d) -> BaseLog.unregister e d)
+      (BaseLog.filter [ocamlbuild_clean_ev])
 
 
   (** Determine real build directory *)
@@ -6610,12 +6918,17 @@
   open BaseEnv
   open OCamlbuildCommon
   open BaseStandardVar
+  open BaseMessage
+
+
+
 
 
-  let cond_targets_hook = ref (fun lst -> lst)
+  let cond_targets_hook =
+    ref (fun lst -> lst)
 
 
-  let build ~ctxt extra_args pkg argv =
+  let build extra_args pkg argv =
     (* Return the filename in build directory *)
     let in_build_dir fn =
       Filename.concat
@@ -6679,8 +6992,8 @@
                           (List.map
                              (List.filter
                                 (fun fn ->
-                                 ends_with ~what:".cmo" fn
-                                 || ends_with ~what:".cmx" fn))
+                                 ends_with ".cmo" fn
+                                 || ends_with ".cmx" fn))
                              unix_files))
                    in
 
@@ -6695,8 +7008,10 @@
 
              | Executable (cs, bs, exec) when var_choose bs.bs_build ->
                  begin
-                   let evs, _, _ =
-                     BaseBuilt.of_executable in_build_dir_of_unix (cs, bs, exec)
+                   let evs, unix_exec_is, unix_dll_opt =
+                     BaseBuilt.of_executable
+                       in_build_dir_of_unix
+                       (cs, bs, exec)
                    in
 
                    let target ext =
@@ -6710,7 +7025,7 @@
                        (* Fix evs, we want to use the unix_tgt, without copying *)
                        List.map
                          (function
-                            | BaseBuilt.BExec, nm, _ when nm = cs.cs_name ->
+                            | BaseBuilt.BExec, nm, lst when nm = cs.cs_name ->
                                 BaseBuilt.BExec, nm,
                                 [[in_build_dir_of_unix unix_tgt]]
                             | ev ->
@@ -6754,30 +7069,27 @@
                   (List.length fns))
                (String.concat (s_ " or ") (List.map (Printf.sprintf "'%s'") fns)))
         lst;
-        (BaseBuilt.register ~ctxt bt bnm lst)
+        (BaseBuilt.register bt bnm lst)
     in
 
     (* Run the hook *)
     let cond_targets = !cond_targets_hook cond_targets in
 
     (* Run a list of target... *)
-    run_ocamlbuild
-      ~ctxt
-      (List.flatten (List.map snd cond_targets) @ extra_args)
-      argv;
+    run_ocamlbuild (List.flatten (List.map snd cond_targets) @ extra_args) argv;
     (* ... and register events *)
     List.iter check_and_register (List.flatten (List.map fst cond_targets))
 
 
-  let clean ~ctxt pkg extra_args  =
-    run_clean ~ctxt extra_args;
+  let clean pkg extra_args  =
+    run_clean extra_args;
     List.iter
       (function
          | Library (cs, _, _) ->
-             BaseBuilt.unregister ~ctxt BaseBuilt.BLib cs.cs_name
+             BaseBuilt.unregister BaseBuilt.BLib cs.cs_name
          | Executable (cs, _, _) ->
-             BaseBuilt.unregister ~ctxt BaseBuilt.BExec cs.cs_name;
-             BaseBuilt.unregister ~ctxt BaseBuilt.BExecLib cs.cs_name
+             BaseBuilt.unregister BaseBuilt.BExec cs.cs_name;
+             BaseBuilt.unregister BaseBuilt.BExecLib cs.cs_name
          | _ ->
              ())
       pkg.sections
@@ -6796,7 +7108,11 @@
 
   open OASISTypes
   open OASISGettext
+  open OASISMessage
   open OCamlbuildCommon
+  open BaseStandardVar
+
+
 
 
   type run_t =
@@ -6806,7 +7122,7 @@
     }
 
 
-  let doc_build ~ctxt run _ (cs, _) argv =
+  let doc_build run pkg (cs, doc) argv =
     let index_html =
       OASISUnixPath.make
         [
@@ -6823,26 +7139,26 @@
           cs.cs_name^".docdir";
         ]
     in
-    run_ocamlbuild ~ctxt (index_html :: run.extra_args) argv;
+      run_ocamlbuild (index_html :: run.extra_args) argv;
     List.iter
       (fun glb ->
          BaseBuilt.register
-           ~ctxt
            BaseBuilt.BDoc
            cs.cs_name
-           [OASISFileUtil.glob ~ctxt (Filename.concat tgt_dir glb)])
+             [OASISFileUtil.glob ~ctxt:!BaseContext.default
+                (Filename.concat tgt_dir glb)])
       ["*.html"; "*.css"]
 
 
-  let doc_clean ~ctxt _ _ (cs, _) argv =
-    run_clean ~ctxt argv;
-    BaseBuilt.unregister ~ctxt BaseBuilt.BDoc cs.cs_name
+  let doc_clean run pkg (cs, doc) argv =
+    run_clean argv;
+    BaseBuilt.unregister BaseBuilt.BDoc cs.cs_name
 
 
 end
 
 
-# 6847 "setup.ml"
+# 7163 "setup.ml"
 open OASISTypes;;
 
 let setup_t =
@@ -6853,7 +7169,7 @@
          [
             "-use-ocamlfind";
             "-plugin-tags";
-            "'package(js-build-tools.ocamlbuild_goodies)'"
+            "\"package(js-build-tools.ocamlbuild_goodies)\""
          ];
      test = [];
      doc = [];
@@ -6869,6 +7185,10 @@
        {
           oasis_version = "0.4";
           ocaml_version = Some (OASISVersion.VGreaterEqual "4.02.3");
+          findlib_version = Some (OASISVersion.VGreaterEqual "1.3.2");
+          alpha_features = ["ocamlbuild_more_args"];
+          beta_features = ["section_object"];
+          name = "ppx_driver";
           version = "113.33.04";
           license =
             OASISLicense.DEP5License
@@ -6878,10 +7198,6 @@
                     excption = None;
                     version = OASISLicense.Version "2.0"
                  });
-          findlib_version = Some (OASISVersion.VGreaterEqual "1.3.2");
-          alpha_features = ["ocamlbuild_more_args"];
-          beta_features = ["section_object"];
-          name = "ppx_driver";
           license_file = Some "LICENSE.txt";
           copyrights =
             [
@@ -6891,7 +7207,6 @@
             ["Jane Street Group"; "LLC <opensource@janestreet.com>"];
           authors = ["Jane Street Group"; "LLC <opensource@janestreet.com>"];
           homepage = Some "https://github.com/janestreet/ppx_driver";
-          bugreports = None;
           synopsis = "Feature-full driver for OCaml AST transformers";
           description =
             Some
@@ -6899,8 +7214,40 @@
                  OASISText.Para
                    "Part of the Jane Street's PPX rewriters collection."
               ];
-          tags = [];
           categories = [];
+          conf_type = (`Configure, "internal", Some "0.4");
+          conf_custom =
+            {
+               pre_command = [(OASISExpr.EBool true, None)];
+               post_command = [(OASISExpr.EBool true, None)]
+            };
+          build_type = (`Build, "ocamlbuild", Some "0.4");
+          build_custom =
+            {
+               pre_command = [(OASISExpr.EBool true, None)];
+               post_command = [(OASISExpr.EBool true, None)]
+            };
+          install_type = (`Install, "internal", Some "0.4");
+          install_custom =
+            {
+               pre_command = [(OASISExpr.EBool true, None)];
+               post_command = [(OASISExpr.EBool true, None)]
+            };
+          uninstall_custom =
+            {
+               pre_command = [(OASISExpr.EBool true, None)];
+               post_command = [(OASISExpr.EBool true, None)]
+            };
+          clean_custom =
+            {
+               pre_command = [(OASISExpr.EBool true, None)];
+               post_command = [(OASISExpr.EBool true, None)]
+            };
+          distclean_custom =
+            {
+               pre_command = [(OASISExpr.EBool true, None)];
+               post_command = [(OASISExpr.EBool true, None)]
+            };
           files_ab = ["META.ab"];
           sections =
             [
@@ -6921,119 +7268,8 @@
                            FindlibPackage ("ppx_optcomp", None)
                         ];
                       bs_build_tools = [ExternalTool "ocamlbuild"];
-                      bs_interface_patterns =
-                        [
-                           {
-                              OASISSourcePatterns.Templater.atoms =
-                                [
-                                   OASISSourcePatterns.Templater.Text "";
-                                   OASISSourcePatterns.Templater.Expr
-                                     (OASISSourcePatterns.Templater.Call
-                                        ("capitalize_file",
-                                          OASISSourcePatterns.Templater.Ident
-                                            "module"));
-                                   OASISSourcePatterns.Templater.Text ".mli"
-                                ];
-                              origin = "${capitalize_file module}.mli"
-                           };
-                           {
-                              OASISSourcePatterns.Templater.atoms =
-                                [
-                                   OASISSourcePatterns.Templater.Text "";
-                                   OASISSourcePatterns.Templater.Expr
-                                     (OASISSourcePatterns.Templater.Call
-                                        ("uncapitalize_file",
-                                          OASISSourcePatterns.Templater.Ident
-                                            "module"));
-                                   OASISSourcePatterns.Templater.Text ".mli"
-                                ];
-                              origin = "${uncapitalize_file module}.mli"
-                           }
-                        ];
-                      bs_implementation_patterns =
-                        [
-                           {
-                              OASISSourcePatterns.Templater.atoms =
-                                [
-                                   OASISSourcePatterns.Templater.Text "";
-                                   OASISSourcePatterns.Templater.Expr
-                                     (OASISSourcePatterns.Templater.Call
-                                        ("capitalize_file",
-                                          OASISSourcePatterns.Templater.Ident
-                                            "module"));
-                                   OASISSourcePatterns.Templater.Text ".ml"
-                                ];
-                              origin = "${capitalize_file module}.ml"
-                           };
-                           {
-                              OASISSourcePatterns.Templater.atoms =
-                                [
-                                   OASISSourcePatterns.Templater.Text "";
-                                   OASISSourcePatterns.Templater.Expr
-                                     (OASISSourcePatterns.Templater.Call
-                                        ("uncapitalize_file",
-                                          OASISSourcePatterns.Templater.Ident
-                                            "module"));
-                                   OASISSourcePatterns.Templater.Text ".ml"
-                                ];
-                              origin = "${uncapitalize_file module}.ml"
-                           };
-                           {
-                              OASISSourcePatterns.Templater.atoms =
-                                [
-                                   OASISSourcePatterns.Templater.Text "";
-                                   OASISSourcePatterns.Templater.Expr
-                                     (OASISSourcePatterns.Templater.Call
-                                        ("capitalize_file",
-                                          OASISSourcePatterns.Templater.Ident
-                                            "module"));
-                                   OASISSourcePatterns.Templater.Text ".mll"
-                                ];
-                              origin = "${capitalize_file module}.mll"
-                           };
-                           {
-                              OASISSourcePatterns.Templater.atoms =
-                                [
-                                   OASISSourcePatterns.Templater.Text "";
-                                   OASISSourcePatterns.Templater.Expr
-                                     (OASISSourcePatterns.Templater.Call
-                                        ("uncapitalize_file",
-                                          OASISSourcePatterns.Templater.Ident
-                                            "module"));
-                                   OASISSourcePatterns.Templater.Text ".mll"
-                                ];
-                              origin = "${uncapitalize_file module}.mll"
-                           };
-                           {
-                              OASISSourcePatterns.Templater.atoms =
-                                [
-                                   OASISSourcePatterns.Templater.Text "";
-                                   OASISSourcePatterns.Templater.Expr
-                                     (OASISSourcePatterns.Templater.Call
-                                        ("capitalize_file",
-                                          OASISSourcePatterns.Templater.Ident
-                                            "module"));
-                                   OASISSourcePatterns.Templater.Text ".mly"
-                                ];
-                              origin = "${capitalize_file module}.mly"
-                           };
-                           {
-                              OASISSourcePatterns.Templater.atoms =
-                                [
-                                   OASISSourcePatterns.Templater.Text "";
-                                   OASISSourcePatterns.Templater.Expr
-                                     (OASISSourcePatterns.Templater.Call
-                                        ("uncapitalize_file",
-                                          OASISSourcePatterns.Templater.Ident
-                                            "module"));
-                                   OASISSourcePatterns.Templater.Text ".mly"
-                                ];
-                              origin = "${uncapitalize_file module}.mly"
-                           }
-                        ];
                       bs_c_sources = [];
                       bs_data_files = [];
-                      bs_findlib_extra_files = [];
                       bs_ccopt = [(OASISExpr.EBool true, [])];
                       bs_cclib = [(OASISExpr.EBool true, [])];
                       bs_dlllib = [(OASISExpr.EBool true, [])];
@@ -7047,7 +7283,6 @@
                       lib_internal_modules = [];
                       lib_findlib_parent = None;
                       lib_findlib_name = None;
-                      lib_findlib_directory = None;
                       lib_findlib_containers = []
                    });
                Library
@@ -7064,119 +7299,8 @@
                       bs_build_depends =
                         [FindlibPackage ("ocamlbuild", None)];
                       bs_build_tools = [ExternalTool "ocamlbuild"];
-                      bs_interface_patterns =
-                        [
-                           {
-                              OASISSourcePatterns.Templater.atoms =
-                                [
-                                   OASISSourcePatterns.Templater.Text "";
-                                   OASISSourcePatterns.Templater.Expr
-                                     (OASISSourcePatterns.Templater.Call
-                                        ("capitalize_file",
-                                          OASISSourcePatterns.Templater.Ident
-                                            "module"));
-                                   OASISSourcePatterns.Templater.Text ".mli"
-                                ];
-                              origin = "${capitalize_file module}.mli"
-                           };
-                           {
-                              OASISSourcePatterns.Templater.atoms =
-                                [
-                                   OASISSourcePatterns.Templater.Text "";
-                                   OASISSourcePatterns.Templater.Expr
-                                     (OASISSourcePatterns.Templater.Call
-                                        ("uncapitalize_file",
-                                          OASISSourcePatterns.Templater.Ident
-                                            "module"));
-                                   OASISSourcePatterns.Templater.Text ".mli"
-                                ];
-                              origin = "${uncapitalize_file module}.mli"
-                           }
-                        ];
-                      bs_implementation_patterns =
-                        [
-                           {
-                              OASISSourcePatterns.Templater.atoms =
-                                [
-                                   OASISSourcePatterns.Templater.Text "";
-                                   OASISSourcePatterns.Templater.Expr
-                                     (OASISSourcePatterns.Templater.Call
-                                        ("capitalize_file",
-                                          OASISSourcePatterns.Templater.Ident
-                                            "module"));
-                                   OASISSourcePatterns.Templater.Text ".ml"
-                                ];
-                              origin = "${capitalize_file module}.ml"
-                           };
-                           {
-                              OASISSourcePatterns.Templater.atoms =
-                                [
-                                   OASISSourcePatterns.Templater.Text "";
-                                   OASISSourcePatterns.Templater.Expr
-                                     (OASISSourcePatterns.Templater.Call
-                                        ("uncapitalize_file",
-                                          OASISSourcePatterns.Templater.Ident
-                                            "module"));
-                                   OASISSourcePatterns.Templater.Text ".ml"
-                                ];
-                              origin = "${uncapitalize_file module}.ml"
-                           };
-                           {
-                              OASISSourcePatterns.Templater.atoms =
-                                [
-                                   OASISSourcePatterns.Templater.Text "";
-                                   OASISSourcePatterns.Templater.Expr
-                                     (OASISSourcePatterns.Templater.Call
-                                        ("capitalize_file",
-                                          OASISSourcePatterns.Templater.Ident
-                                            "module"));
-                                   OASISSourcePatterns.Templater.Text ".mll"
-                                ];
-                              origin = "${capitalize_file module}.mll"
-                           };
-                           {
-                              OASISSourcePatterns.Templater.atoms =
-                                [
-                                   OASISSourcePatterns.Templater.Text "";
-                                   OASISSourcePatterns.Templater.Expr
-                                     (OASISSourcePatterns.Templater.Call
-                                        ("uncapitalize_file",
-                                          OASISSourcePatterns.Templater.Ident
-                                            "module"));
-                                   OASISSourcePatterns.Templater.Text ".mll"
-                                ];
-                              origin = "${uncapitalize_file module}.mll"
-                           };
-                           {
-                              OASISSourcePatterns.Templater.atoms =
-                                [
-                                   OASISSourcePatterns.Templater.Text "";
-                                   OASISSourcePatterns.Templater.Expr
-                                     (OASISSourcePatterns.Templater.Call
-                                        ("capitalize_file",
-                                          OASISSourcePatterns.Templater.Ident
-                                            "module"));
-                                   OASISSourcePatterns.Templater.Text ".mly"
-                                ];
-                              origin = "${capitalize_file module}.mly"
-                           };
-                           {
-                              OASISSourcePatterns.Templater.atoms =
-                                [
-                                   OASISSourcePatterns.Templater.Text "";
-                                   OASISSourcePatterns.Templater.Expr
-                                     (OASISSourcePatterns.Templater.Call
-                                        ("uncapitalize_file",
-                                          OASISSourcePatterns.Templater.Ident
-                                            "module"));
-                                   OASISSourcePatterns.Templater.Text ".mly"
-                                ];
-                              origin = "${uncapitalize_file module}.mly"
-                           }
-                        ];
                       bs_c_sources = [];
                       bs_data_files = [];
-                      bs_findlib_extra_files = [];
                       bs_ccopt = [(OASISExpr.EBool true, [])];
                       bs_cclib = [(OASISExpr.EBool true, [])];
                       bs_dlllib = [(OASISExpr.EBool true, [])];
@@ -7190,7 +7314,6 @@
                       lib_internal_modules = [];
                       lib_findlib_parent = None;
                       lib_findlib_name = None;
-                      lib_findlib_directory = None;
                       lib_findlib_containers = []
                    });
                Library
@@ -7206,119 +7329,8 @@
                       bs_compiled_object = Best;
                       bs_build_depends = [InternalLibrary "ppx_driver"];
                       bs_build_tools = [ExternalTool "ocamlbuild"];
-                      bs_interface_patterns =
-                        [
-                           {
-                              OASISSourcePatterns.Templater.atoms =
-                                [
-                                   OASISSourcePatterns.Templater.Text "";
-                                   OASISSourcePatterns.Templater.Expr
-                                     (OASISSourcePatterns.Templater.Call
-                                        ("capitalize_file",
-                                          OASISSourcePatterns.Templater.Ident
-                                            "module"));
-                                   OASISSourcePatterns.Templater.Text ".mli"
-                                ];
-                              origin = "${capitalize_file module}.mli"
-                           };
-                           {
-                              OASISSourcePatterns.Templater.atoms =
-                                [
-                                   OASISSourcePatterns.Templater.Text "";
-                                   OASISSourcePatterns.Templater.Expr
-                                     (OASISSourcePatterns.Templater.Call
-                                        ("uncapitalize_file",
-                                          OASISSourcePatterns.Templater.Ident
-                                            "module"));
-                                   OASISSourcePatterns.Templater.Text ".mli"
-                                ];
-                              origin = "${uncapitalize_file module}.mli"
-                           }
-                        ];
-                      bs_implementation_patterns =
-                        [
-                           {
-                              OASISSourcePatterns.Templater.atoms =
-                                [
-                                   OASISSourcePatterns.Templater.Text "";
-                                   OASISSourcePatterns.Templater.Expr
-                                     (OASISSourcePatterns.Templater.Call
-                                        ("capitalize_file",
-                                          OASISSourcePatterns.Templater.Ident
-                                            "module"));
-                                   OASISSourcePatterns.Templater.Text ".ml"
-                                ];
-                              origin = "${capitalize_file module}.ml"
-                           };
-                           {
-                              OASISSourcePatterns.Templater.atoms =
-                                [
-                                   OASISSourcePatterns.Templater.Text "";
-                                   OASISSourcePatterns.Templater.Expr
-                                     (OASISSourcePatterns.Templater.Call
-                                        ("uncapitalize_file",
-                                          OASISSourcePatterns.Templater.Ident
-                                            "module"));
-                                   OASISSourcePatterns.Templater.Text ".ml"
-                                ];
-                              origin = "${uncapitalize_file module}.ml"
-                           };
-                           {
-                              OASISSourcePatterns.Templater.atoms =
-                                [
-                                   OASISSourcePatterns.Templater.Text "";
-                                   OASISSourcePatterns.Templater.Expr
-                                     (OASISSourcePatterns.Templater.Call
-                                        ("capitalize_file",
-                                          OASISSourcePatterns.Templater.Ident
-                                            "module"));
-                                   OASISSourcePatterns.Templater.Text ".mll"
-                                ];
-                              origin = "${capitalize_file module}.mll"
-                           };
-                           {
-                              OASISSourcePatterns.Templater.atoms =
-                                [
-                                   OASISSourcePatterns.Templater.Text "";
-                                   OASISSourcePatterns.Templater.Expr
-                                     (OASISSourcePatterns.Templater.Call
-                                        ("uncapitalize_file",
-                                          OASISSourcePatterns.Templater.Ident
-                                            "module"));
-                                   OASISSourcePatterns.Templater.Text ".mll"
-                                ];
-                              origin = "${uncapitalize_file module}.mll"
-                           };
-                           {
-                              OASISSourcePatterns.Templater.atoms =
-                                [
-                                   OASISSourcePatterns.Templater.Text "";
-                                   OASISSourcePatterns.Templater.Expr
-                                     (OASISSourcePatterns.Templater.Call
-                                        ("capitalize_file",
-                                          OASISSourcePatterns.Templater.Ident
-                                            "module"));
-                                   OASISSourcePatterns.Templater.Text ".mly"
-                                ];
-                              origin = "${capitalize_file module}.mly"
-                           };
-                           {
-                              OASISSourcePatterns.Templater.atoms =
-                                [
-                                   OASISSourcePatterns.Templater.Text "";
-                                   OASISSourcePatterns.Templater.Expr
-                                     (OASISSourcePatterns.Templater.Call
-                                        ("uncapitalize_file",
-                                          OASISSourcePatterns.Templater.Ident
-                                            "module"));
-                                   OASISSourcePatterns.Templater.Text ".mly"
-                                ];
-                              origin = "${uncapitalize_file module}.mly"
-                           }
-                        ];
                       bs_c_sources = [];
                       bs_data_files = [];
-                      bs_findlib_extra_files = [];
                       bs_ccopt = [(OASISExpr.EBool true, [])];
                       bs_cclib = [(OASISExpr.EBool true, [])];
                       bs_dlllib = [(OASISExpr.EBool true, [])];
@@ -7332,7 +7344,6 @@
                       lib_internal_modules = [];
                       lib_findlib_parent = None;
                       lib_findlib_name = None;
-                      lib_findlib_directory = None;
                       lib_findlib_containers = []
                    });
                Library
@@ -7348,119 +7359,8 @@
                       bs_compiled_object = Best;
                       bs_build_depends = [InternalLibrary "ppx_driver"];
                       bs_build_tools = [ExternalTool "ocamlbuild"];
-                      bs_interface_patterns =
-                        [
-                           {
-                              OASISSourcePatterns.Templater.atoms =
-                                [
-                                   OASISSourcePatterns.Templater.Text "";
-                                   OASISSourcePatterns.Templater.Expr
-                                     (OASISSourcePatterns.Templater.Call
-                                        ("capitalize_file",
-                                          OASISSourcePatterns.Templater.Ident
-                                            "module"));
-                                   OASISSourcePatterns.Templater.Text ".mli"
-                                ];
-                              origin = "${capitalize_file module}.mli"
-                           };
-                           {
-                              OASISSourcePatterns.Templater.atoms =
-                                [
-                                   OASISSourcePatterns.Templater.Text "";
-                                   OASISSourcePatterns.Templater.Expr
-                                     (OASISSourcePatterns.Templater.Call
-                                        ("uncapitalize_file",
-                                          OASISSourcePatterns.Templater.Ident
-                                            "module"));
-                                   OASISSourcePatterns.Templater.Text ".mli"
-                                ];
-                              origin = "${uncapitalize_file module}.mli"
-                           }
-                        ];
-                      bs_implementation_patterns =
-                        [
-                           {
-                              OASISSourcePatterns.Templater.atoms =
-                                [
-                                   OASISSourcePatterns.Templater.Text "";
-                                   OASISSourcePatterns.Templater.Expr
-                                     (OASISSourcePatterns.Templater.Call
-                                        ("capitalize_file",
-                                          OASISSourcePatterns.Templater.Ident
-                                            "module"));
-                                   OASISSourcePatterns.Templater.Text ".ml"
-                                ];
-                              origin = "${capitalize_file module}.ml"
-                           };
-                           {
-                              OASISSourcePatterns.Templater.atoms =
-                                [
-                                   OASISSourcePatterns.Templater.Text "";
-                                   OASISSourcePatterns.Templater.Expr
-                                     (OASISSourcePatterns.Templater.Call
-                                        ("uncapitalize_file",
-                                          OASISSourcePatterns.Templater.Ident
-                                            "module"));
-                                   OASISSourcePatterns.Templater.Text ".ml"
-                                ];
-                              origin = "${uncapitalize_file module}.ml"
-                           };
-                           {
-                              OASISSourcePatterns.Templater.atoms =
-                                [
-                                   OASISSourcePatterns.Templater.Text "";
-                                   OASISSourcePatterns.Templater.Expr
-                                     (OASISSourcePatterns.Templater.Call
-                                        ("capitalize_file",
-                                          OASISSourcePatterns.Templater.Ident
-                                            "module"));
-                                   OASISSourcePatterns.Templater.Text ".mll"
-                                ];
-                              origin = "${capitalize_file module}.mll"
-                           };
-                           {
-                              OASISSourcePatterns.Templater.atoms =
-                                [
-                                   OASISSourcePatterns.Templater.Text "";
-                                   OASISSourcePatterns.Templater.Expr
-                                     (OASISSourcePatterns.Templater.Call
-                                        ("uncapitalize_file",
-                                          OASISSourcePatterns.Templater.Ident
-                                            "module"));
-                                   OASISSourcePatterns.Templater.Text ".mll"
-                                ];
-                              origin = "${uncapitalize_file module}.mll"
-                           };
-                           {
-                              OASISSourcePatterns.Templater.atoms =
-                                [
-                                   OASISSourcePatterns.Templater.Text "";
-                                   OASISSourcePatterns.Templater.Expr
-                                     (OASISSourcePatterns.Templater.Call
-                                        ("capitalize_file",
-                                          OASISSourcePatterns.Templater.Ident
-                                            "module"));
-                                   OASISSourcePatterns.Templater.Text ".mly"
-                                ];
-                              origin = "${capitalize_file module}.mly"
-                           };
-                           {
-                              OASISSourcePatterns.Templater.atoms =
-                                [
-                                   OASISSourcePatterns.Templater.Text "";
-                                   OASISSourcePatterns.Templater.Expr
-                                     (OASISSourcePatterns.Templater.Call
-                                        ("uncapitalize_file",
-                                          OASISSourcePatterns.Templater.Ident
-                                            "module"));
-                                   OASISSourcePatterns.Templater.Text ".mly"
-                                ];
-                              origin = "${uncapitalize_file module}.mly"
-                           }
-                        ];
                       bs_c_sources = [];
                       bs_data_files = [];
-                      bs_findlib_extra_files = [];
                       bs_ccopt = [(OASISExpr.EBool true, [])];
                       bs_cclib = [(OASISExpr.EBool true, [])];
                       bs_dlllib = [(OASISExpr.EBool true, [])];
@@ -7474,54 +7374,20 @@
                       lib_internal_modules = [];
                       lib_findlib_parent = None;
                       lib_findlib_name = None;
-                      lib_findlib_directory = None;
                       lib_findlib_containers = []
                    })
             ];
-          disable_oasis_section = [];
-          conf_type = (`Configure, "internal", Some "0.4");
-          conf_custom =
-            {
-               pre_command = [(OASISExpr.EBool true, None)];
-               post_command = [(OASISExpr.EBool true, None)]
-            };
-          build_type = (`Build, "ocamlbuild", Some "0.4");
-          build_custom =
-            {
-               pre_command = [(OASISExpr.EBool true, None)];
-               post_command = [(OASISExpr.EBool true, None)]
-            };
-          install_type = (`Install, "internal", Some "0.4");
-          install_custom =
-            {
-               pre_command = [(OASISExpr.EBool true, None)];
-               post_command = [(OASISExpr.EBool true, None)]
-            };
-          uninstall_custom =
-            {
-               pre_command = [(OASISExpr.EBool true, None)];
-               post_command = [(OASISExpr.EBool true, None)]
-            };
-          clean_custom =
-            {
-               pre_command = [(OASISExpr.EBool true, None)];
-               post_command = [(OASISExpr.EBool true, None)]
-            };
-          distclean_custom =
-            {
-               pre_command = [(OASISExpr.EBool true, None)];
-               post_command = [(OASISExpr.EBool true, None)]
-            };
           plugins =
             [
                (`Extra, "StdFiles", Some "0.3");
                (`Extra, "DevFiles", Some "0.3")
             ];
+          disable_oasis_section = [];
           schema_data = PropList.Data.create ();
           plugin_data = []
        };
      oasis_fn = Some "_oasis";
-     oasis_version = "0.4.8";
+     oasis_version = "0.4.6";
      oasis_digest = Some "Q\148O\025\178s\238\132d\218\171\168\207\150$b";
      oasis_exec = None;
      oasis_setup_args = [];
@@ -7530,9 +7396,7 @@
 
 let setup () = BaseSetup.setup setup_t;;
 
-# 7536 "setup.ml"
-let setup_t = BaseCompat.Compat_0_4.adapt_setup_t setup_t
-open BaseCompat.Compat_0_4
+# 7402 "setup.ml"
 (* OASIS_STOP *)
 
 let () = setup ()

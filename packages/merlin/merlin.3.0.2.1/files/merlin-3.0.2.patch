--- ./configure
+++ ./configure
@@ -244,30 +244,40 @@
 ## ============================
 
 OS_TYPE=$(ocamlfind c -config | sed -ne "s/os_type: //p" | tr -d '\015')
+CCOMP_TYPE=$(ocamlfind c -config | sed -ne "s/ccomp_type: //p" | tr -d '\015')
 
 # 64-bit Windows also has OS_TYPE = Win32
-case "$OS_TYPE" in
-  Win32)
-    # Assume windows-like system
-    # Avoid symlinks, find right version through environment variable
-    touch "$PWD/src/ocaml"
-    MERLIN_CONFIG_ENV="$MERLIN_CONFIG_ENV
+if [ "$OS_TYPE" = "Win32" ] ; then
+  EXE=.exe
+  MERLIN_CONFIG_ENV="$MERLIN_CONFIG_ENV
+export CC=$(ocamlfind c -config | sed -ne "s/bytecomp_c_compiler: //p" | cut -d' ' -f1) \$(CFLAGS)
+"
+  ln -sf configure conftestLink
+  # The easiest way of checking that a native Windows symbolic link was created!
+  if [ "`cmd /c dir conftestLink 2>/dev/null | fgrep SYMLINK`" = "" ] ; then
+    SYMLINK=false
+  else
+    SYMLINK=true
+  fi
+  rm -f conftestLink
+else
+  EXE=
+  SYMLINK=true
+fi
+
+if $SYMLINK ; then
+  rm -f "$PWD/src/ocaml/typer" 2>&1 >/dev/null
+  ln -sf "$PWD/src/ocaml/typer_$OCAML_VERSION" "$PWD/src/ocaml/typer"
+  rm -f "$PWD/src/sturgeon" 2>&1 >/dev/null
+  ln -sf "$PWD/src/sturgeon_$STURGEON_VERSION" "$PWD/src/sturgeon"
+else
+  # Avoid symlinks, find right version through environment variable
+  touch "$PWD/src/ocaml"
+  MERLIN_CONFIG_ENV="$MERLIN_CONFIG_ENV
 export MERLIN_OCAML_VERSION=_${OCAML_VERSION}
 export MERLIN_STURGEON_VERSION=_${STURGEON_VERSION}
 "
-    EXE=.exe
-    ;;
-
-  *)
-    # Non windows-like system, use symlinks
-    rm -f "$PWD/src/ocaml/typer" 2>&1 >/dev/null
-    ln -sf "$PWD/src/ocaml/typer_$OCAML_VERSION" "$PWD/src/ocaml/typer"
-    rm -f "$PWD/src/sturgeon" 2>&1 >/dev/null
-    ln -sf "$PWD/src/sturgeon_$STURGEON_VERSION" "$PWD/src/sturgeon"
-
-    EXE=
-    ;;
-esac
+fi
 
 # Configuration report
 # ====================
@@ -304,7 +314,8 @@
 NATIVE=$NATIVE
 WITH_BIN_ANNOT=$WITH_BIN_ANNOT
 ENABLE_COMPILED_EMACS_MODE=$ENABLE_COMPILED_EMACS_MODE
-EXE=$EXE
+export EXE=$EXE
+CCOMP_TYPE=$CCOMP_TYPE
 $MERLIN_CONFIG_ENV
 END
 
--- ./Makefile
+++ ./Makefile
@@ -3,7 +3,7 @@
 -include Makefile.config
 TARGET = ocamlmerlin-server
 
-ifdef ENABLE_COMPILED_EMACS_MODE
+ifeq ($(ENABLE_COMPILED_EMACS_MODE),true)
     TARGET_EMACS = emacs/merlin.elc \
 									 emacs/merlin-iedit.elc \
 									 emacs/merlin-imenu.elc \
@@ -30,23 +30,23 @@
 
 #### Default rule
 
-all: $(TARGET) $(TARGET_EMACS) ocamlmerlin
+all: $(TARGET) $(TARGET_EMACS) ocamlmerlin$(EXE)
 
 #### Check configuration
 
 CONFIG_FILES = src/config/my_config.ml src/ocaml/typer
-$(CONFIG_FILES):
+$(CONFIG_FILES)$(MERLIN_OCAML_VERSION):
 	@echo "Please run ./configure"
 	@if [ -d ._d ]; then printf \
 		"WARNING:\n\tThere are some build leftovers.\n\tConsider doing a 'make clean' before continuing.\n"; fi
 	@false
 
-assert_configured: $(CONFIG_FILES)
+assert_configured: $(CONFIG_FILES)$(MERLIN_OCAML_VERSION)
 
 #### C wrapper
 
-ocamlmerlin: src/frontend/ocamlmerlin.c
-	$(CC) -o $@ $^
+ocamlmerlin$(EXE): src/frontend/ocamlmerlin.c
+	$(CC) $(if $(filter-out msvc,$(CCOMP_TYPE)),-o ,/nologo /Fe)$@ $^ $(if $(filter msvc,$(CCOMP_TYPE)),advapi32.lib)
 
 #### Other rules
 
@@ -57,7 +57,7 @@
 
 test: assert_configured
 	 +$(OCAMLMAKEFILE) PROJECT=test
-	 ./ocamlmerlin-test
+	 ./ocamlmerlin-test$(EXE)
 
 preprocess:
 	$(MAKE) -f Makefile.preprocess
@@ -74,17 +74,17 @@
 	@rm -f src/ocaml/*/*/*.cmly
 	$(MAKE) preprocessclean
 	@find src/ -name '*.cm*' -delete
-	@rm -f ocamlmerlin ocamlmerlin-test
+	@rm -f ocamlmerlin$(EXE) ocamlmerlin-test$(EXE)
 	+$(OCAMLMAKEFILE) clean
 
 distclean: clean
 	@echo
-	rm -f $(TARGET)
+	rm -f $(TARGET)$(EXE)
 
 preprocessclean:
 	$(MAKE) -f Makefile.preprocess clean
 
-install-binary: $(TARGET) ocamlmerlin
+install-binary: $(TARGET) ocamlmerlin$(EXE)
 	install -d $(BIN_DIR)
 	install $(TARGET)$(EXE) $(BIN_DIR)/ocamlmerlin-server$(EXE)
 	install ocamlmerlin$(EXE) $(BIN_DIR)/ocamlmerlin$(EXE)
@@ -133,7 +133,8 @@
 	@echo "Manually run 'sh merlin.install.sh' to update merlin.install"
 
 uninstall:
-	rm -rf $(SHARE_DIR)/ocamlmerlin \
-				 $(BIN_DIR)/ocamlmerlin   \
+	rm -rf $(SHARE_DIR)/ocamlmerlin$(EXE) \
+				 $(BIN_DIR)/ocamlmerlin$(EXE)   \
+				 $(BIN_DIR)/ocamlmerlin-server$(EXE)   \
 				 $(SHARE_DIR)/emacs/site-lisp/merlin.el \
 				 $(SHARE_DIR)/emacs/site-lisp/merlin.elc
--- ./OCamlMakefile
+++ ./OCamlMakefile
@@ -112,7 +112,7 @@
 
 ####################  variables depending on your OCaml-installation
 
-SYSTEM := $(shell $(OCAMLFIND) c -config 2>/dev/null | grep system | sed 's/system: //')
+SYSTEM := $(shell $(OCAMLFIND) c -config 2>/dev/null | sed -ne "s/system: //p" | tr -d '\015')
     # This may be
     # - mingw
     # - mingw64
@@ -146,8 +146,8 @@
   #endif
   ## The OCaml C header files use this flag:
   #CFLAGS += -D__MINGW32__
-  CC:= $(shell $(OCAMLFIND) ocamlc -config | awk '/^bytecomp_c_compiler/ {for(i=2;i<=NF;i++) printf "%s " ,$$i}')
-  AR:= $(shell $(OCAMLFIND) ocamlc -config | awk '/^bytecomp_c_compiler/ {print $$2}' | sed 's|gcc|ar|g')
+  CC:= $(shell $(OCAMLFIND) ocamlc -config | awk '/^bytecomp_c_compiler/ {for(i=2;i<=NF;i++) printf "%s " ,$$i}' | tr -d '\015')
+  AR:= $(shell $(OCAMLFIND) ocamlc -config | awk '/^bytecomp_c_compiler/ {print $$2}' | sed 's|gcc|ar|g' | tr -d '\015')
 endif
 ifdef MSVC
   export MSVC
--- ./src/frontend/ocamlmerlin.c
+++ ./src/frontend/ocamlmerlin.c
@@ -2,15 +2,39 @@
 #include <stdio.h>
 #include <string.h>
 #include <signal.h>
+#ifdef _WIN32
+/* GetNamedPipeServerProcessId requires Windows Vista+ */
+#undef _WIN32_WINNT
+#define _WIN32_WINNT 0x600
+#include <windows.h>
+#include <Lmcons.h>
+#include <process.h>
+#ifndef STDIN_FILENO
+#define STDIN_FILENO 0
+#endif
+#ifndef STDOUT_FILENO
+#define STDOUT_FILENO 1
+#endif
+#ifndef STDERR_FILENO
+#define STDERR_FILENO 2
+#endif
+#ifdef _MSC_VER
+typedef SSIZE_T ssize_t;
+#define PATH_MAX MAX_PATH
+#ifndef _UCRT
+#define snprintf _snprintf
+#endif
+#endif
+#else
 #include <unistd.h>
 #include <sys/socket.h>
 #include <sys/un.h>
 #include <sys/stat.h>
 #include <sys/wait.h>
 #include <libgen.h>
+#endif
 #include <errno.h>
 #include <sys/types.h>
-#include <sys/stat.h>
 #include <fcntl.h>
 
 #if defined(__linux)
@@ -84,6 +108,19 @@
   return tmpdir;
 }
 
+#ifdef _WIN32
+/** Deal with Windows IPC **/
+
+static void ipc_send(HANDLE hPipe, unsigned char *buffer, size_t len, HANDLE fds[3])
+{
+  DWORD dwNumberOfBytesWritten;
+  if (!WriteFile(hPipe, fds, 3 * sizeof(HANDLE), &dwNumberOfBytesWritten, NULL) || dwNumberOfBytesWritten != 3 * sizeof(HANDLE))
+    failwith_perror("sendmsg");
+  if (!WriteFile(hPipe, buffer, len, &dwNumberOfBytesWritten, NULL) || dwNumberOfBytesWritten != len)
+    failwith_perror("send");
+}
+
+#else
 /** Deal with UNIX IPC **/
 
 static void ipc_send(int fd, unsigned char *buffer, size_t len, int fds[3])
@@ -123,6 +160,7 @@
     sent += sent_;
   }
 }
+#endif
 
 /* Serialize arguments */
 
@@ -161,9 +199,9 @@
   /* Append env var */
   for (i = 0; envvars[i] != NULL; ++i)
   {
+    const char *v = getenv(envvars[i]);
     append_argument(buffer, len, &j, envvars[i]);
 
-    const char *v = getenv(envvars[i]);
     if (v != NULL)
     {
       j -= 1; /* Overwrite delimiting 0 */
@@ -190,6 +228,19 @@
   return j;
 }
 
+#ifdef _WIN32
+#define IPC_SOCKET_TYPE HANDLE
+static HANDLE connect_socket(const char *socketname, int fail)
+{
+  HANDLE hPipe;
+  hPipe = CreateFile(socketname, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0);
+  if (hPipe == INVALID_HANDLE_VALUE)
+    if (fail) failwith_perror("connect");
+  return hPipe;
+}
+#else
+#define IPC_SOCKET_TYPE int
+#define INVALID_HANDLE_VALUE -1
 static int connect_socket(const char *socketname, int fail)
 {
   int sock = socket(PF_UNIX, SOCK_STREAM, 0);
@@ -218,7 +269,30 @@
 
   return sock;
 }
+#endif
 
+#ifdef _WIN32
+static void start_server(const char *socketname, const char* eventname, const char *exec_path)
+{
+  char buf[PATHSZ];
+  PROCESS_INFORMATION pi;
+  STARTUPINFO si;
+  HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, eventname);
+  DWORD dwResult;
+  sprintf(buf, "%s server %s %s", exec_path, socketname, eventname);
+  ZeroMemory(&si, sizeof(si));
+  si.cb = sizeof(si);
+  ZeroMemory(&pi, sizeof(pi));
+  /* Note that DETACHED_PROCESS means that the process does not appear in Task Manager
+     but the server can still be stopped with ocamlmerlin server stop-server */
+  if (!CreateProcess(exec_path, buf, NULL, NULL, FALSE, DETACHED_PROCESS, NULL, NULL, &si, &pi))
+    failwith_perror("fork");
+  CloseHandle(pi.hProcess);
+  CloseHandle(pi.hThread);
+  if (WaitForSingleObject(hEvent, 5000) != WAIT_OBJECT_0)
+    failwith_perror("execlp");
+}
+#else
 static void make_daemon(int sock)
 {
   /* On success: The child process becomes session leader */
@@ -256,7 +330,7 @@
     exit(EXIT_SUCCESS);
 }
 
-static void start_server(const char *socketname, const char *exec_path)
+static void start_server(const char *socketname, const char* ignored, const char *exec_path)
 {
   int sock = socket(PF_UNIX, SOCK_STREAM, 0);
   if (sock == -1)
@@ -303,18 +377,19 @@
   close(sock);
   wait(NULL);
 }
+#endif
 
-static int connect_and_serve(const char *socket_path, const char *exec_path)
+static IPC_SOCKET_TYPE connect_and_serve(const char *socket_path, const char* event_path, const char *exec_path)
 {
-  int sock = connect_socket(socket_path, 0);
+  IPC_SOCKET_TYPE sock = connect_socket(socket_path, 0);
 
-  if (sock == -1)
+  if (sock == INVALID_HANDLE_VALUE)
   {
-    start_server(socket_path, exec_path);
+    start_server(socket_path, event_path, exec_path);
     sock = connect_socket(socket_path, 1);
   }
 
-  if (sock == -1)
+  if (sock == INVALID_HANDLE_VALUE)
     abort();
 
   return sock;
@@ -325,6 +400,10 @@
 static const char *search_in_path(const char *PATH, const char *argv0, char *merlin_path)
 {
   static char binary_path[PATHSZ];
+#ifdef _WIN32
+  char *result = NULL;
+  DWORD dwResult;
+#endif
 
   if (PATH == NULL || argv0 == NULL) return NULL;
 
@@ -341,10 +420,10 @@
 
     // Append filename
     {
+      const char *file = argv0;
       binary_path[i] = '/';
       i += 1;
 
-      const char *file = argv0;
       while (i < PATHSZ-1 && *file)
       {
         binary_path[i] = *file;
@@ -357,7 +436,14 @@
     }
 
     // Check path
+#ifdef _WIN32
+    dwResult = GetFullPathName(binary_path, PATHSZ, merlin_path, NULL);
+    if (dwResult && dwResult < PATHSZ)
+      if (GetLongPathName(binary_path, NULL, 0))
+        result = binary_path;
+#else
     char *result = realpath(binary_path, merlin_path);
+#endif
     if (result != NULL)
       return result;
 
@@ -374,13 +460,20 @@
 
 static void prune_binary_name(char * buffer) {
   size_t strsz = strlen(buffer);
-  while (strsz > 0 && buffer[strsz-1] != '/')
+  while (strsz > 0 && buffer[strsz-1] != '/' && buffer[strsz-1] != '\\')
     strsz -= 1;
   buffer[strsz] = 0;
 }
 
+#ifdef _WIN32
+#define OCAMLMERLIN_SERVER "ocamlmerlin-server.exe"
+#else
+#define OCAMLMERLIN_SERVER "ocamlmerlin-server"
+#endif
+
 static void compute_merlinpath(char merlin_path[PATHSZ], const char *argv0) {
   char argv0_dirname[PATHSZ];
+  size_t strsz;
 
   strcpy(argv0_dirname, argv0);
   prune_binary_name(argv0_dirname);
@@ -390,22 +483,54 @@
     if (search_in_path(getenv("PATH"), argv0, merlin_path) == NULL)
       failwith("cannot resolve path to ocamlmerlin");
   } else {
+#ifdef _WIN32
+    // GetFullPathName does not resolve symbolic links, which realpath does.
+    // @@DRA GetLongPathName ensures that the file exists (better way?!).
+    // Not sure if this matters.
+    DWORD dwResult = GetFullPathName(argv0, PATHSZ, merlin_path, NULL);
+    if (!dwResult || dwResult >= PATHSZ || !GetLongPathName(merlin_path, NULL, 0))
+#else
     if (realpath(argv0, merlin_path) == NULL)
+#endif
       failwith("argv0 does not point to a valid file");
   }
 
   prune_binary_name(merlin_path);
-  size_t strsz = strlen(merlin_path);
+  strsz = strlen(merlin_path);
 
   // Append ocamlmerlin-server
   if (strsz + 19 > PATHSZ)
     failwith("path is too long");
 
-  strcpy(merlin_path + strsz, "ocamlmerlin-server");
+  strcpy(merlin_path + strsz, OCAMLMERLIN_SERVER);
 }
 
+#ifdef _WIN32
+static void compute_socketname(char socketname[PATHSZ], char eventname[PATHSZ], const char merlin_path[PATHSZ])
+#else
 static void compute_socketname(char socketname[PATHSZ], const char merlin_path[PATHSZ])
+#endif
 {
+#ifdef _WIN32
+  CHAR user[UNLEN + 1];
+  DWORD dwBufSize = UNLEN;
+  BY_HANDLE_FILE_INFORMATION info;
+  HANDLE hFile = CreateFile(merlin_path, FILE_READ_ATTRIBUTES, FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
+  if (hFile == INVALID_HANDLE_VALUE || !GetFileInformationByHandle(hFile, &info))
+    failwith_perror("stat (cannot find ocamlmerlin binary)");
+  CloseHandle(hFile);
+
+  if (!GetUserName(user, &dwBufSize))
+    user[0] = '\0';
+  // @@DRA Need to use Windows API functions to get meaningful values for st_dev and st_ino
+  snprintf(eventname, PATHSZ,
+      "ocamlmerlin_%s_%lx_%llx",
+      user,
+      info.dwVolumeSerialNumber,
+      ((__int64)info.nFileIndexHigh) << 32 | ((__int64)info.nFileIndexLow));
+  snprintf(socketname, PATHSZ,
+      "\\\\.\\pipe\\%s", eventname);
+#else
   struct stat st;
   if (stat(merlin_path, &st) != 0)
     failwith_perror("stat (cannot find ocamlmerlin binary)");
@@ -415,13 +540,15 @@
       (unsigned long long)getuid(),
       (unsigned long long)st.st_dev,
       (unsigned long long)st.st_ino);
+#endif
 }
 
 /* Main */
 
 static char
   merlin_path[PATHSZ] = "<not computed yet>",
-  socketname[PATHSZ] = "<not computed yet>";
+  socketname[PATHSZ] = "<not computed yet>",
+  eventname[PATHSZ] = "<not computed yet>";
 static unsigned char argbuffer[65536];
 
 static void dumpinfo(void)
@@ -430,7 +557,7 @@
       "merlin path: %s\nsocket path: %s/%s\n", merlin_path, path_socketdir(), socketname);
 }
 
-static void abnormal_termination(int argc, char **argv)
+static void unexpected_termination(int argc, char **argv)
 {
   int sexp = 0;
   int i;
@@ -451,27 +578,64 @@
 
 int main(int argc, char **argv)
 {
-  compute_merlinpath(merlin_path, argv[0]);
+  char result = 0;
+  int err = 0;
+#ifdef _WIN32
+  HANDLE fds[3];
+  ULONG pid;
+  HANDLE hProcess, hServerProcess;
+  DWORD dwNumberOfBytesRead;
+  CHAR argv0[PATHSZ];
+  GetModuleFileName(NULL, argv0, PATHSZ);
+#else
+  char* argv0 = argv[0];
+#endif
+  compute_merlinpath(merlin_path, argv0);
   if (argc >= 2 && strcmp(argv[1], "server") == 0)
   {
+    IPC_SOCKET_TYPE sock;
+    ssize_t len;
+#ifdef _WIN32
+    compute_socketname(socketname, eventname, merlin_path);
+#else
     compute_socketname(socketname, merlin_path);
+#endif
 
-    int sock = connect_and_serve(socketname, merlin_path);
-    ssize_t len = prepare_args(argbuffer, sizeof(argbuffer), argc-2, argv+2);
+    sock = connect_and_serve(socketname, eventname, merlin_path);
+    len = prepare_args(argbuffer, sizeof(argbuffer), argc-2, argv+2);
+#ifdef _WIN32
+    hProcess = GetCurrentProcess();
+    if (!GetNamedPipeServerProcessId(sock, &pid))
+      failwith_perror("GetNamedPipeServerProcessId");
+    hServerProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, pid);
+    if (hServerProcess == INVALID_HANDLE_VALUE)
+      failwith_perror("OpenProcess");
+    if (!DuplicateHandle(hProcess, GetStdHandle(STD_INPUT_HANDLE), hServerProcess, &fds[0], 0, FALSE, DUPLICATE_SAME_ACCESS))
+      failwith_perror("DuplicateHandle(stdin)");
+    if (!DuplicateHandle(hProcess, GetStdHandle(STD_OUTPUT_HANDLE), hServerProcess, &fds[1], 0, FALSE, DUPLICATE_SAME_ACCESS))
+      failwith_perror("DuplicateHandle(stdout)");
+    CloseHandle(GetStdHandle(STD_OUTPUT_HANDLE));
+    if (!DuplicateHandle(hProcess, GetStdHandle(STD_ERROR_HANDLE), hServerProcess, &fds[2], 0, FALSE, DUPLICATE_SAME_ACCESS))
+      failwith_perror("DuplicateHandle(stderr)");
+#else
     int fds[3] = { STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO };
+#endif
     ipc_send(sock, argbuffer, len, fds);
 
-    char result = 0;
-    int err;
+#ifdef _WIN32
+    if (ReadFile(sock, &result, 1, &dwNumberOfBytesRead, NULL) && dwNumberOfBytesRead == 1)
+      err = 1;
+#else
     NO_EINTR(err, read(sock, &result, 1));
+#endif
     if (err == 1)
       exit(result);
 
-    abnormal_termination(argc, argv);
+    unexpected_termination(argc, argv);
   }
   else
   {
-    argv[0] = "ocamlmerlin-server";
+    argv[0] = OCAMLMERLIN_SERVER;
     execvp(merlin_path, argv);
     failwith_perror("execvp(ocamlmerlin-server)");
   }
--- ./src/frontend/test/ocamlmerlin_test.ml
+++ ./src/frontend/test/ocamlmerlin_test.ml
@@ -230,6 +230,7 @@
             item dump config;
         )
     in
+    let cwd = Filename.get_temp_dir_name () in
     [
       (* Simple name is not expanded *)
       test_ppx_path "simple_name" ["-ppx"; "test1"] "test1";
@@ -238,12 +239,12 @@
       test_ppx_path "absolute_path" ["-ppx"; "/test2"] "/test2";
 
       (* Relative name is expanded *)
-      test_ppx_path "relative_path" ~cwd:"/tmp"
-        ["-ppx"; "./test3"] "/tmp/test3";
+      test_ppx_path "relative_path" ~cwd
+        ["-ppx"; "./test3"] (Filename.concat cwd "test3");
 
       (* Quoted flags inherit path *)
-      test_ppx_path "quoted_path" ~cwd:"/tmp"
-        ["-flags"; "-ppx ./test4"] "/tmp/test4";
+      test_ppx_path "quoted_path" ~cwd
+        ["-flags"; "-ppx ./test4"] (Filename.concat cwd "test4");
     ]
 
   );
--- ./src/platform/os_ipc_stub.c
+++ ./src/platform/os_ipc_stub.c
@@ -2,11 +2,27 @@
 #include <stdio.h>
 #include <string.h>
 #include <errno.h>
+#ifdef _WIN32
+#include <windows.h>
+#include <io.h>
+#ifndef STDIN_FILENO
+#define STDIN_FILENO 0
+#endif
+#ifndef STDOUT_FILENO
+#define STDOUT_FILENO 1
+#endif
+#ifndef STDERR_FILENO
+#define STDERR_FILENO 2
+#endif
+#ifdef _MSC_VER
+typedef SSIZE_T ssize_t;
+#endif
+#else
 #include <unistd.h>
 #include <alloca.h>
 #include <sys/socket.h>
 #include <sys/select.h>
-
+#endif
 #include <caml/mlvalues.h>
 #include <caml/memory.h>
 #include <caml/alloc.h>
@@ -14,12 +30,18 @@
 value ml_merlin_unsetenv(value key)
 {
   CAMLparam1(key);
+#ifdef _WIN32
+  SetEnvironmentVariable(String_val(key), NULL);
+#else
   unsetenv(String_val(key));
+#endif
   CAMLreturn(Val_unit);
 }
 
-static unsigned char buffer[65536];
+#define BUFFER_SIZE 65536
+static unsigned char buffer[BUFFER_SIZE];
 
+#ifndef _WIN32
 #define NO_EINTR(var, command) \
   do { (var) = command; } while ((var) == -1 && errno == EINTR)
 
@@ -92,20 +114,32 @@
 
   return recvd;
 }
+#endif
 
 value ml_merlin_server_setup(value path, value strfd)
 {
   CAMLparam2(path, strfd);
   CAMLlocal2(payload, ret);
   char *endptr = NULL;
+  int fd;
+
+#ifdef _WIN32
+  fd = 0;
+  ret = strfd;
+#else
+  fd = strtol(String_val(strfd), &endptr, 0);
+  if (!endptr || *endptr != '\0')
+    fd = -1;
+  else
+    ret = Val_int(fd);
+#endif
 
-  int fd = strtol(String_val(strfd), &endptr, 0);
-  if (endptr && *endptr == '\0')
+  if (fd != -1)
   {
     /* (path, fd) */
     payload = caml_alloc(2, 0);
     Store_field(payload, 0, path);
-    Store_field(payload, 1, Val_int(fd));
+    Store_field(payload, 1, ret);
 
     /* Some payload */
     ret = caml_alloc(1, 0);
@@ -128,6 +162,54 @@
   CAMLparam2(server, val_timeout);
   CAMLlocal4(ret, client, args, context);
 
+  ssize_t len = -1;
+
+#ifdef _WIN32
+  static BOOL bDoneReset = FALSE;
+  HANDLE hPipe = CreateNamedPipe(String_val(Field(server, 0)), PIPE_ACCESS_DUPLEX, PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, 1024, 1024, NMPWAIT_USE_DEFAULT_WAIT, NULL);
+  ret = Val_unit; /* None */
+  if (hPipe != INVALID_HANDLE_VALUE)
+  {
+    if (!bDoneReset)
+    {
+      HANDLE hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, String_val(Field(server, 1)));
+      SetEvent(hEvent);
+      CloseHandle(hEvent);
+      bDoneReset = TRUE;
+    }
+    if (ConnectNamedPipe(hPipe, NULL) || GetLastError() == ERROR_PIPE_CONNECTED)
+    {
+      intptr_t fds[3];
+      DWORD dwNumberOfBytesRead;
+      if (ReadFile(hPipe, fds, 3 * sizeof(HANDLE), &dwNumberOfBytesRead, NULL) && dwNumberOfBytesRead == 3 * sizeof(HANDLE))
+      {
+        context = caml_alloc(4, 0); /* hPipe, stdin, stdout, stderr) */
+        Store_field(context, 0, caml_copy_nativeint((intnat)hPipe));
+        Store_field(context, 1, Val_int(_open_osfhandle(fds[0], 0)));
+        Store_field(context, 2, Val_int(_open_osfhandle(fds[1], 0)));
+        Store_field(context, 3, Val_int(_open_osfhandle(fds[2], 0)));
+        if (ReadFile(hPipe, buffer, BUFFER_SIZE, &dwNumberOfBytesRead, NULL))
+        {
+          len = dwNumberOfBytesRead;
+        }
+        else
+        {
+          DisconnectNamedPipe(hPipe);
+          CloseHandle(hPipe);
+        }
+      }
+      else
+      {
+        DisconnectNamedPipe(hPipe);
+        CloseHandle(hPipe);
+      }
+    }
+    else
+    {
+      CloseHandle(hPipe);
+    }
+  }
+#else
   // Compute timeout
   double timeout = Double_val(val_timeout);
   struct timeval tv;
@@ -145,7 +227,6 @@
   } while (selectres == -1 && errno == EINTR);
 
   int fds[3], clientfd;
-  ssize_t len = -1;
 
   if (selectres > 0)
   {
@@ -161,7 +242,11 @@
     Store_field(context, 1, Val_int(fds[0]));
     Store_field(context, 2, Val_int(fds[1]));
     Store_field(context, 3, Val_int(fds[2]));
+  }
+#endif
 
+  if (len != -1)
+  {
     ssize_t i, j;
     int argc = 0;
     for (i = 4; i < len; ++i)
@@ -196,8 +281,10 @@
 value ml_merlin_server_close(value server)
 {
   CAMLparam1(server);
+#ifndef _WIN32
   unlink(String_val(Field(server, 0)));
   close(Int_val(Field(server, 1)));
+#endif
   CAMLreturn(Val_unit);
 }
 
@@ -235,12 +322,21 @@
 value ml_merlin_context_close(value context, value return_code)
 {
   CAMLparam1(context);
-  setup_fds(-1, -1, -1);
-
   char code = (char)(Int_val(return_code));
-
+#ifdef _WIN32
+  HANDLE hPipe;
+  DWORD dwNumberOfBytesWritten;
+#else
   ssize_t wrote_ = -1;
+#endif
+  setup_fds(-1, -1, -1);
+
+#ifdef _WIN32
+  hPipe = (HANDLE)Nativeint_val(Field(context, 0));
+  WriteFile(hPipe, &code, sizeof(char), &dwNumberOfBytesWritten, NULL);
+#else
   NO_EINTR(wrote_, write(Int_val(Field(context, 0)), &code, sizeof(char)));
+#endif
 
   // Close stdin, stdout, stderr
   close(Int_val(Field(context, 1)));
@@ -248,7 +344,13 @@
   close(Int_val(Field(context, 3)));
 
   // Close client connection
+#ifdef _WIN32
+  FlushFileBuffers(hPipe);
+  DisconnectNamedPipe(hPipe);
+  CloseHandle(hPipe);
+#else
   close(Int_val(Field(context, 0)));
+#endif
 
   CAMLreturn(Val_unit);
 }

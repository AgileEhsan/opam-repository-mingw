--- ./src/command.ml
+++ ./src/command.ml
@@ -148,9 +148,10 @@
   let self = string_of_command_spec_with_calls call_with_tags call_with_target resolve_virtuals in
   let b = Buffer.create 256 in
   (* The best way to prevent bash from switching to its windows-style
-   * quote-handling is to prepend an empty string before the command name. *)
+   * quote-handling is to prepend an empty string before the command name.
+   * space seems to work, too - and the ouput is nicer *)
   if Sys.os_type = "Win32" then
-    Buffer.add_string b "''";
+    Buffer.add_string b " ";
   let first = ref true in
   let put_space () =
     if !first then
--- ./src/findlib.ml
+++ ./src/findlib.ml
@@ -66,9 +66,6 @@
     (fun command -> lexer & Lexing.from_string & run_and_read command)
     command
 
-let run_and_read command =
-  Printf.ksprintf run_and_read command
-
 let rec query name =
   try
     Hashtbl.find packages name
@@ -135,7 +132,8 @@
   with Not_found -> s
 
 let list () =
-  List.map before_space (split_nl & run_and_read "%s list" ocamlfind)
+  let cmd = Shell.quote_filename_if_needed ocamlfind ^ " list" in
+  List.map before_space (split_nl & run_and_read cmd)
 
 (* The closure algorithm is easy because the dependencies are already closed
 and sorted for each package. We only have to make the union. We could also
--- ./src/main.ml
+++ ./src/main.ml
@@ -146,7 +146,13 @@
             else Pathname.pwd / path_name in
           ignore (Configuration.parse_file ?dir tags_path);
         end;
-
+        let path_normalize p =
+          let p = Pathname.normalize p in
+          if Sys.win32 = false then
+            p
+          else
+            String.map ( fun c -> if c = '\\' then '/' else c ) p
+        in
         (name <> !Options.build_dir && not (List.mem name !Options.exclude_dirs))
         && begin
           not (path_name <> Filename.current_dir_name && Pathname.is_directory path_name)
@@ -160,8 +166,8 @@
               || List.exists (Pathname.is_prefix path_name) !Options.include_dirs
               || List.exists (Pathname.is_prefix path_name) target_dirs)
             && ((* beware: !Options.build_dir is an absolute directory *)
-                Pathname.normalize !Options.build_dir
-                <> Pathname.normalize (Pathname.pwd/path_name))
+                path_normalize !Options.build_dir
+                <> path_normalize (Pathname.pwd/path_name))
           end
         end
       end
--- ./src/my_std.ml
+++ ./src/my_std.ml
@@ -274,7 +274,7 @@
   match Sys.os_type with
   | "Win32" -> fun cmd ->
       if cmd = "" then 0 else
-      let cmd = "bash --norc -c "^Filename.quote cmd in
+      let cmd = "bash --norc --noprofile -c "^Filename.quote cmd in
       Sys.command cmd
   | _ -> fun cmd -> if cmd = "" then 0 else Sys.command cmd
 
--- ./src/ocamlbuild_unix_plugin.ml
+++ ./src/ocamlbuild_unix_plugin.ml
@@ -48,6 +48,14 @@
   end
 
 let run_and_open s kont =
+  let s =
+    (* Be consistent! My_unix.run_and_open uses My_std.sys_command and
+       sys_command uses bash. *)
+    if Sys.win32 then
+      "bash --norc --noprofile -c " ^ Filename.quote s
+    else
+      s
+  in
   let ic = Unix.open_process_in s in
   let close () =
     match Unix.close_process_in ic with
--- ./src/shell.ml
+++ ./src/shell.ml
@@ -24,12 +24,26 @@
     | 'a'..'z' | 'A'..'Z' | '0'..'9' | '.' | '-' | '/' | '_' | ':' | '@' | '+' | ',' -> loop (pos + 1)
     | _ -> false in
   loop 0
+
+let generic_quote quotequote s =
+  let l = String.length s in
+  let b = Buffer.create (l + 20) in
+  Buffer.add_char b '\'';
+  for i = 0 to l - 1 do
+    if s.[i] = '\''
+    then Buffer.add_string b quotequote
+    else Buffer.add_char b  s.[i]
+  done;
+  Buffer.add_char b '\'';
+  Buffer.contents b
+let unix_quote = generic_quote "'\\''"
+
 let quote_filename_if_needed s =
   if is_simple_filename s then s
   (* We should probably be using [Filename.unix_quote] except that function
    * isn't exported. Users on Windows will have to live with not being able to
    * install OCaml into c:\o'caml. Too bad. *)
-  else if Sys.os_type = "Win32" then Printf.sprintf "'%s'" s
+  else if Sys.os_type = "Win32" then unix_quote s
   else Filename.quote s
 let chdir dir =
   reset_filesys_cache ();

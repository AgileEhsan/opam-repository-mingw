--- ./_tags
+++ ./_tags
@@ -1,5 +1,5 @@
 # OASIS_START
-# DO NOT EDIT (digest: 18d6a9ae3a887cdc314214db86f3efa1)
+# DO NOT EDIT (digest: 04c751f11aab007003cdf0cde6531eb8)
 # Ignore VCS directories, you can use the same kind of rule outside 
 # OASIS_START/STOP if you want to exclude directories that contains 
 # useless stuff for the build process
--- ./myocamlbuild.ml
+++ ./myocamlbuild.ml
@@ -1,7 +1,8 @@
 (* OASIS_START *)
-(* DO NOT EDIT (digest: 43f1836cd9872683a3d2c218ba881ffe) *)
+(* DO NOT EDIT (digest: 29c9941dc2e9b1b939f55999196115c2) *)
 module OASISGettext = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/oasis/OASISGettext.ml" *)
+(* # 22 "src/oasis/OASISGettext.ml" *)
+
 
   let ns_ str =
     str
@@ -9,9 +11,11 @@
   let s_ str =
     str
 
-  let f_ (str : ('a, 'b, 'c, 'd) format4) =
+
+  let f_ (str: ('a, 'b, 'c, 'd) format4) =
     str
 
+
   let fn_ fmt1 fmt2 n =
     if n = 1 then
       fmt1^^""
@@ -24,7 +30,9 @@
 end
 
 module OASISExpr = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/oasis/OASISExpr.ml" *)
+(* # 22 "src/oasis/OASISExpr.ml" *)
+
+
 
 
 
@@ -114,9 +129,10 @@
 end
 
 
-# 117 "myocamlbuild.ml"
+# 132 "myocamlbuild.ml"
 module BaseEnvLight = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/base/BaseEnvLight.ml" *)
+(* # 22 "src/base/BaseEnvLight.ml" *)
+
 
   module MapString = Map.Make(String)
 
@@ -212,9 +233,10 @@
 end
 
 
-# 215 "myocamlbuild.ml"
+# 236 "myocamlbuild.ml"
 module MyOCamlbuildFindlib = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/plugins/ocamlbuild/MyOCamlbuildFindlib.ml" *)
+(* # 22 "src/plugins/ocamlbuild/MyOCamlbuildFindlib.ml" *)
+
 
   (** OCamlbuild extension, copied from 
     * http://brion.inria.fr/gallium/index.php/Using_ocamlfind_with_ocamlbuild
@@ -233,20 +257,24 @@
   let blank_sep_strings = 
     Ocamlbuild_pack.Lexers.blank_sep_strings
 
+
   let split s ch =
-    let x = 
-      ref [] 
-    in
-    let rec go s =
-      let pos = 
-        String.index s ch 
-      in
-        x := (String.before s pos)::!x;
-        go (String.after s (pos + 1))
-    in
-      try
-        go s
-      with Not_found -> !x
+    let buf = Buffer.create 13 in
+    let x = ref [] in
+    let flush () =
+      x := (Buffer.contents buf) :: !x;
+      Buffer.clear buf
+    in
+      String.iter
+        (fun c ->
+           if c = ch then
+             flush ()
+           else
+             Buffer.add_char buf c)
+        s;
+      flush ();
+      List.rev !x
+
 
   let split_nl s = split s '\n'
 
@@ -255,31 +284,45 @@
       String.before s (String.index s ' ')
     with Not_found -> s
 
-  (* this lists all supported packages *)
+  (* ocamlfind command *)
+  let ocamlfind x =
+    let ocamlfind_prog =
+      let env_filename = Pathname.basename BaseEnvLight.default_filename in
+      let env = BaseEnvLight.load ~filename:env_filename ~allow_empty:true () in
+      try
+        BaseEnvLight.var_get "ocamlfind" env
+      with Not_found ->
+        Printf.eprintf "W: Cannot get variable ocamlfind";
+        "ocamlfind"
+    in
+      S[Sh ocamlfind_prog; x]
+
+  (* This lists all supported packages. *)
   let find_packages () =
     List.map before_space (split_nl & run_and_read "ocamlfind list")
 
-  (* this is supposed to list available syntaxes, but I don't know how to do it. *)
+
+  (* Mock to list available syntaxes. *)
   let find_syntaxes () = ["camlp4o"; "camlp4r"]
 
-  (* ocamlfind command *)
-  let ocamlfind x = S[A"ocamlfind"; x]
 
   let dispatch =
     function
       | Before_options ->
-          (* by using Before_options one let command line options have an higher priority *)
-          (* on the contrary using After_options will guarantee to have the higher priority *)
-          (* override default commands by ocamlfind ones *)
+          (* By using Before_options one let command line options have an higher
+           * priority on the contrary using After_options will guarantee to have
+           * the higher priority override default commands by ocamlfind ones *)
           Options.ocamlc     := ocamlfind & A"ocamlc";
           Options.ocamlopt   := ocamlfind & A"ocamlopt";
           Options.ocamldep   := ocamlfind & A"ocamldep";
           Options.ocamldoc   := ocamlfind & A"ocamldoc";
-          Options.ocamlmktop := ocamlfind & A"ocamlmktop"
+          Options.ocamlmktop := ocamlfind & A"ocamlmktop";
+          Options.ocamlmklib := ocamlfind & A"ocamlmklib"
                                   
       | After_rules ->
           
-          (* When one link an OCaml library/binary/package, one should use -linkpkg *)
+          (* When one link an OCaml library/binary/package, one should use
+           * -linkpkg *)
           flag ["ocaml"; "link"; "program"] & A"-linkpkg";
           
           (* For each ocamlfind package one inject the -package option when
@@ -287,11 +330,20 @@
            * linking. *)
           List.iter 
             begin fun pkg ->
-              flag ["ocaml"; "compile";  "pkg_"^pkg] & S[A"-package"; A pkg];
-              flag ["ocaml"; "ocamldep"; "pkg_"^pkg] & S[A"-package"; A pkg];
-              flag ["ocaml"; "doc";      "pkg_"^pkg] & S[A"-package"; A pkg];
-              flag ["ocaml"; "link";     "pkg_"^pkg] & S[A"-package"; A pkg];
-              flag ["ocaml"; "infer_interface"; "pkg_"^pkg] & S[A"-package"; A pkg];
+              let base_args = [A"-package"; A pkg] in
+              let syn_args = [A"-syntax"; A "camlp4o"] in
+              let args =
+          (* Heuristic to identify syntax extensions: whether they end in
+           * ".syntax"; some might not *)
+                if Filename.check_suffix pkg "syntax"
+                then syn_args @ base_args
+                else base_args
+              in
+              flag ["ocaml"; "compile";  "pkg_"^pkg] & S args;
+              flag ["ocaml"; "ocamldep"; "pkg_"^pkg] & S args;
+              flag ["ocaml"; "doc";      "pkg_"^pkg] & S args;
+              flag ["ocaml"; "link";     "pkg_"^pkg] & S base_args;
+              flag ["ocaml"; "infer_interface"; "pkg_"^pkg] & S args;
             end 
             (find_packages ());
 
@@ -301,7 +353,8 @@
           flag ["ocaml"; "compile";  "syntax_"^syntax] & S[A"-syntax"; A syntax];
           flag ["ocaml"; "ocamldep"; "syntax_"^syntax] & S[A"-syntax"; A syntax];
           flag ["ocaml"; "doc";      "syntax_"^syntax] & S[A"-syntax"; A syntax];
-          flag ["ocaml"; "infer_interface"; "syntax_"^syntax] & S[A"-syntax"; A syntax];
+          flag ["ocaml"; "infer_interface"; "syntax_"^syntax] &
+                S[A"-syntax"; A syntax];
           end (find_syntaxes ());
 
           (* The default "thread" tag is not compatible with ocamlfind.
@@ -315,7 +368,11 @@
           flag ["ocaml"; "pkg_threads"; "compile"] (S[A "-thread"]);
           flag ["ocaml"; "pkg_threads"; "doc"] (S[A "-I"; A "+threads"]);
           flag ["ocaml"; "pkg_threads"; "link"] (S[A "-thread"]);
-          flag ["ocaml"; "pkg_threads"; "infer_interface"] (S[A "-thread"])
+          flag ["ocaml"; "pkg_threads"; "infer_interface"] (S[A "-thread"]);
+          flag ["ocaml"; "package(threads)"; "compile"] (S[A "-thread"]);
+          flag ["ocaml"; "package(threads)"; "doc"] (S[A "-I"; A "+threads"]);
+          flag ["ocaml"; "package(threads)"; "link"] (S[A "-thread"]);
+          flag ["ocaml"; "package(threads)"; "infer_interface"] (S[A "-thread"]);
 
       | _ -> 
           ()
@@ -323,7 +379,8 @@
 end
 
 module MyOCamlbuildBase = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/plugins/ocamlbuild/MyOCamlbuildBase.ml" *)
+(* # 22 "src/plugins/ocamlbuild/MyOCamlbuildBase.ml" *)
+
 
   (** Base functions for writing myocamlbuild.ml
       @author Sylvain Le Gall
@@ -339,11 +399,13 @@
   type name = string 
   type tag = string 
 
-(* # 56 "/home/andre/src/oasis-0.3.0/src/plugins/ocamlbuild/MyOCamlbuildBase.ml" *)
+
+(* # 62 "src/plugins/ocamlbuild/MyOCamlbuildBase.ml" *)
+
 
   type t =
       {
-        lib_ocaml: (name * dir list) list;
+        lib_ocaml: (name * dir list * string list) list;
         lib_c:     (name * dir * file list) list; 
         flags:     (tag list * (spec OASISExpr.choices)) list;
         (* Replace the 'dir: include' from _tags by a precise interdepends in
@@ -399,9 +466,13 @@
             (* Declare OCaml libraries *)
             List.iter 
               (function
-                 | nm, [] ->
-                     ocaml_lib nm
-                 | nm, dir :: tl ->
+                 | nm, [], intf_modules ->
+                     ocaml_lib nm;
+                     let cmis =
+                       List.map (fun m -> (String.uncapitalize m) ^ ".cmi")
+                                intf_modules in
+                     dep ["ocaml"; "link"; "library"; "file:"^nm^".cma"] cmis
+                 | nm, dir :: tl, intf_modules ->
                      ocaml_lib ~dir:dir (dir^"/"^nm);
                      List.iter 
                        (fun dir -> 
@@ -409,7 +480,12 @@
                             (fun str ->
                                flag ["ocaml"; "use_"^nm; str] (S[A"-I"; P dir]))
                             ["compile"; "infer_interface"; "doc"])
-                       tl)
+                       tl;
+                     let cmis =
+                       List.map (fun m -> dir^"/"^(String.uncapitalize m)^".cmi")
+                                intf_modules in
+                     dep ["ocaml"; "link"; "library"; "file:"^dir^"/"^nm^".cma"]
+                         cmis)
               t.lib_ocaml;
 
             (* Declare directories dependencies, replace "include" in _tags. *)
@@ -473,20 +551,20 @@
 end
 
 
-# 476 "myocamlbuild.ml"
+# 554 "myocamlbuild.ml"
 open Ocamlbuild_plugin;;
 let package_default =
   {
-     MyOCamlbuildBase.lib_ocaml = [("ospec", ["src"])];
+     MyOCamlbuildBase.lib_ocaml = [("ospec", ["src"], [])];
      lib_c = [];
      flags = [];
-     includes = [];
+     includes = []
      }
   ;;
 
 let dispatch_default = MyOCamlbuildBase.dispatch_default package_default;;
 
-# 490 "myocamlbuild.ml"
+# 568 "myocamlbuild.ml"
 (* OASIS_STOP *)
 let compiler_libs =
   if Sys.ocaml_version.[0] = '4' then
--- ./setup.ml
+++ ./setup.ml
@@ -1,14 +1,15 @@
 (* setup.ml generated for the first time by OASIS v0.2.0 *)
 
 (* OASIS_START *)
-(* DO NOT EDIT (digest: 14a00e6ca2ca4dd2d05d437df43f5c0a) *)
+(* DO NOT EDIT (digest: 39422f7abffbd022c8d753d7feda80e6) *)
 (*
-   Regenerated by OASIS v0.3.0
+   Regenerated by OASIS v0.4.1
    Visit http://oasis.forge.ocamlcore.org for more information and
    documentation about functions used in this file.
 *)
 module OASISGettext = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/oasis/OASISGettext.ml" *)
+(* # 22 "src/oasis/OASISGettext.ml" *)
+
 
   let ns_ str =
     str
@@ -16,9 +18,11 @@
   let s_ str =
     str
 
-  let f_ (str : ('a, 'b, 'c, 'd) format4) =
+
+  let f_ (str: ('a, 'b, 'c, 'd) format4) =
     str
 
+
   let fn_ fmt1 fmt2 n =
     if n = 1 then
       fmt1^^""
@@ -31,7 +37,8 @@
 end
 
 module OASISContext = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/oasis/OASISContext.ml" *)
+(* # 22 "src/oasis/OASISContext.ml" *)
+
 
   open OASISGettext
 
@@ -92,8 +104,7 @@
 end
 
 module OASISString = struct
-(* # 1 "/home/andre/src/oasis-0.3.0/src/oasis/OASISString.ml" *)
-
+(* # 22 "src/oasis/OASISString.ml" *)
 
 
   (** Various string utilities.
@@ -214,10 +235,34 @@
       done;
       buf
 
+  (** Like List.exists, but for strings *)
+  let exists f str =
+    let rec iter i =
+      if i < 0 then
+        false
+      else if f str.[i] then
+        true
+      else
+        iter (pred i)
+    in
+      iter (String.length str - 1)
+
+  let is_digit c =
+    '0' <= c && c <= '9'
+
+  let is_alpha c =
+    ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')
+
+  let is_whitespace =
+    function
+      | ' ' | '\r' | '\n' | '\t' -> true
+      |  _  -> false
+
 end
 
 module OASISUtils = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/oasis/OASISUtils.ml" *)
+(* # 22 "src/oasis/OASISUtils.ml" *)
+
 
   open OASISGettext
 
@@ -312,7 +367,8 @@
 end
 
 module PropList = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/oasis/PropList.ml" *)
+(* # 22 "src/oasis/PropList.ml" *)
+
 
   open OASISGettext
 
@@ -336,7 +395,8 @@
                (Printf.sprintf (f_ "No default printer for value %s") nm)
          | Unknown_field (nm, schm) ->
              Some 
-               (Printf.sprintf (f_ "Field %s is not defined in schema %s") nm schm)
+               (Printf.sprintf
+                  (f_ "Field %s is not defined in schema %s") nm schm)
          | _ ->
              None)
 
@@ -352,12 +412,13 @@
     let clear t =
       Hashtbl.clear t
 
-(* # 71 "/home/andre/src/oasis-0.3.0/src/oasis/PropList.ml" *)
+
+(* # 78 "src/oasis/PropList.ml" *)
   end
 
+
   module Schema =
   struct
-
     type ('ctxt, 'extra) value =
         {
           get:   Data.t -> string;
@@ -593,7 +652,7 @@
 end
 
 module OASISMessage = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/oasis/OASISMessage.ml" *)
+(* # 22 "src/oasis/OASISMessage.ml" *)
 
 
   open OASISGettext
@@ -632,7 +696,8 @@
 end
 
 module OASISVersion = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/oasis/OASISVersion.ml" *)
+(* # 22 "src/oasis/OASISVersion.ml" *)
+
 
   open OASISGettext
 
@@ -652,12 +721,13 @@
     | VAnd of comparator * comparator
     
 
+
   (* Range of allowed characters *)
-  let is_digit c =
-    '0' <= c && c <= '9'
+  let is_digit = OASISString.is_digit
+
+
+  let is_alpha = OASISString.is_alpha
 
-  let is_alpha c =
-    ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')
 
   let is_special =
     function
@@ -747,8 +818,14 @@
 
   let version_of_string str = str
 
+
   let string_of_version t = t
 
+
+  let version_compare_string s1 s2 =
+    version_compare (version_of_string s1) (version_of_string s2)
+
+
   let chop t =
     try
       let pos =
@@ -805,13 +885,24 @@
         | VAnd (c1, c2) ->
             (varname_of_comparator c1)^"_and_"^(varname_of_comparator c2)
 
-  let version_0_3_or_after t =
-    comparator_apply t (VGreaterEqual (string_of_version "0.3"))
+
+  let rec comparator_ge v' =
+    let cmp v = version_compare v v' >= 0 in
+    function
+      | VEqual v
+      | VGreaterEqual v
+      | VGreater v -> cmp v
+      | VLesserEqual _
+      | VLesser _ -> false
+      | VOr (c1, c2) -> comparator_ge v' c1 || comparator_ge v' c2
+      | VAnd (c1, c2) -> comparator_ge v' c1 && comparator_ge v' c2
+
 
 end
 
 module OASISLicense = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/oasis/OASISLicense.ml" *)
+(* # 22 "src/oasis/OASISLicense.ml" *)
+
 
   (** License for _oasis fields
       @author Sylvain Le Gall
@@ -851,7 +950,9 @@
 end
 
 module OASISExpr = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/oasis/OASISExpr.ml" *)
+(* # 22 "src/oasis/OASISExpr.ml" *)
+
+
 
 
 
@@ -941,7 +1049,8 @@
 end
 
 module OASISTypes = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/oasis/OASISTypes.ml" *)
+(* # 22 "src/oasis/OASISTypes.ml" *)
+
 
 
 
@@ -1012,13 +1128,18 @@
        | `Other of string
       ]
 
+
   type 'a plugin = 'a * name * OASISVersion.t option 
 
+
   type all_plugin = plugin_kind plugin
 
+
   type plugin_data = (all_plugin * plugin_data_purpose * (unit -> unit)) list
 
-(* # 102 "/home/andre/src/oasis-0.3.0/src/oasis/OASISTypes.ml" *)
+
+(* # 115 "src/oasis/OASISTypes.ml" *)
+
 
   type 'a conditional = 'a OASISExpr.choices 
 
@@ -1066,6 +1191,14 @@
         lib_findlib_containers: findlib_name list;
       } 
 
+
+  type object_ =
+      {
+        obj_modules:            string list;
+        obj_findlib_fullname:   findlib_name list option;
+      }
+
+
   type executable =
       {
         exec_custom:          bool;
@@ -1124,8 +1262,10 @@
         doc_build_tools: tool list;
       } 
 
+
   type section =
     | Library    of common_section * build_section * library
+    | Object     of common_section * build_section * object_
     | Executable of common_section * build_section * executable
     | Flag       of common_section * flag
     | SrcRepo    of common_section * source_repository
@@ -1133,14 +1273,18 @@
     | Doc        of common_section * doc
     
 
+
   type section_kind =
-      [ `Library | `Executable | `Flag | `SrcRepo | `Test | `Doc ]
+      [ `Library | `Object | `Executable | `Flag | `SrcRepo | `Test | `Doc ]
+
 
   type package = 
       {
         oasis_version:    OASISVersion.t;
         ocaml_version:    OASISVersion.comparator option;
         findlib_version:  OASISVersion.comparator option;
+        alpha_features:   string list;
+        beta_features:    string list;
         name:             package_name;
         version:          OASISVersion.t;
         license:          OASISLicense.t;
@@ -1173,10 +1317,334 @@
         plugin_data:      plugin_data;
       } 
 
+
+end
+
+module OASISFeatures = struct
+(* # 22 "src/oasis/OASISFeatures.ml" *)
+
+  open OASISTypes
+  open OASISUtils
+  open OASISGettext
+  open OASISVersion
+
+  module MapPlugin =
+    Map.Make
+      (struct
+         type t = plugin_kind * name
+         let compare = Pervasives.compare
+       end)
+
+  module Data =
+  struct
+    type t =
+        {
+          oasis_version: OASISVersion.t;
+          plugin_versions: OASISVersion.t option MapPlugin.t;
+          alpha_features: string list;
+          beta_features: string list;
+        }
+
+    let create oasis_version alpha_features beta_features =
+      {
+        oasis_version = oasis_version;
+        plugin_versions = MapPlugin.empty;
+        alpha_features = alpha_features;
+        beta_features = beta_features
+      }
+
+    let of_package pkg =
+      create
+        pkg.OASISTypes.oasis_version
+        pkg.OASISTypes.alpha_features
+        pkg.OASISTypes.beta_features
+
+    let add_plugin (plugin_kind, plugin_name, plugin_version) t =
+      {t with
+           plugin_versions = MapPlugin.add
+                               (plugin_kind, plugin_name)
+                               plugin_version
+                               t.plugin_versions}
+
+    let plugin_version plugin_kind plugin_name t =
+      MapPlugin.find (plugin_kind, plugin_name) t.plugin_versions
+  end
+
+  type origin =
+    | Field of string * string
+    | Section of string
+    | NoOrigin
+
+  type stage = Alpha | Beta
+
+
+  let string_of_stage =
+    function
+      | Alpha -> "alpha"
+      | Beta -> "beta"
+
+
+  let field_of_stage =
+    function
+      | Alpha -> "AlphaFeatures"
+      | Beta -> "BetaFeatures"
+
+  type publication = InDev of stage | SinceVersion of OASISVersion.t
+
+  type t =
+      {
+        name: string;
+        plugin: all_plugin option;
+        publication: publication;
+        description: unit -> string;
+      }
+
+  (* TODO: mutex protect this. *)
+  let all_features = Hashtbl.create 13
+
+
+  let since_version ver_str = SinceVersion (version_of_string ver_str)
+  let alpha = InDev Alpha
+  let beta = InDev Beta
+
+
+  let data_check t data origin =
+    let no_message = "no message" in
+
+    let check_feature features stage =
+      let has_feature = List.mem t.name features in
+      if not has_feature then
+        match origin with
+          | Field (fld, where) ->
+              Some
+                (Printf.sprintf
+                   (f_ "Field %s in %s is only available when feature %s \
+                        is in field %s.")
+                   fld where t.name (field_of_stage stage))
+          | Section sct ->
+              Some
+                (Printf.sprintf
+                   (f_ "Section %s is only available when features %s \
+                        is in field %s.")
+                   sct t.name (field_of_stage stage))
+          | NoOrigin ->
+              Some no_message
+      else
+        None
+    in
+
+    let version_is_good ~min_version version fmt =
+      let version_is_good =
+        OASISVersion.comparator_apply
+          version (OASISVersion.VGreaterEqual min_version)
+      in
+        Printf.ksprintf
+          (fun str ->
+             if version_is_good then
+               None
+             else
+               Some str)
+          fmt
+    in
+
+    match origin, t.plugin, t.publication with
+      | _, _, InDev Alpha -> check_feature data.Data.alpha_features Alpha
+      | _, _, InDev Beta -> check_feature data.Data.beta_features Beta
+      | Field(fld, where), None, SinceVersion min_version ->
+          version_is_good ~min_version data.Data.oasis_version
+            (f_ "Field %s in %s is only valid since OASIS v%s, update \
+                 OASISFormat field from '%s' to '%s' after checking \
+                 OASIS changelog.")
+            fld where (string_of_version min_version)
+            (string_of_version data.Data.oasis_version)
+            (string_of_version min_version)
+
+      | Field(fld, where), Some(plugin_knd, plugin_name, _),
+        SinceVersion min_version ->
+          begin
+            try
+              let plugin_version_current =
+                try
+                  match Data.plugin_version plugin_knd plugin_name data with
+                    | Some ver -> ver
+                    | None ->
+                        failwithf
+                          (f_ "Field %s in %s is only valid for the OASIS \
+                               plugin %s since v%s, but no plugin version is \
+                               defined in the _oasis file, change '%s' to \
+                               '%s (%s)' in your _oasis file.")
+                          fld where plugin_name (string_of_version min_version)
+                          plugin_name
+                          plugin_name (string_of_version min_version)
+                with Not_found ->
+                  failwithf
+                    (f_ "Field %s in %s is only valid when the OASIS plugin %s \
+                         is defined.")
+                    fld where plugin_name
+              in
+              version_is_good ~min_version plugin_version_current
+                (f_ "Field %s in %s is only valid for the OASIS plugin %s \
+                     since v%s, update your plugin from '%s (%s)' to \
+                     '%s (%s)' after checking the plugin's changelog.")
+                fld where plugin_name (string_of_version min_version)
+                plugin_name (string_of_version plugin_version_current)
+                plugin_name (string_of_version min_version)
+            with Failure msg ->
+              Some msg
+          end
+
+      | Section sct, None, SinceVersion min_version ->
+          version_is_good ~min_version data.Data.oasis_version
+            (f_ "Section %s is only valid for since OASIS v%s, update \
+                 OASISFormat field from '%s' to '%s' after checking OASIS \
+                 changelog.")
+            sct (string_of_version min_version)
+            (string_of_version data.Data.oasis_version)
+            (string_of_version min_version)
+
+      | Section sct, Some(plugin_knd, plugin_name, _),
+        SinceVersion min_version ->
+          begin
+            try
+              let plugin_version_current =
+                try
+                  match Data.plugin_version plugin_knd plugin_name data with
+                    | Some ver -> ver
+                    | None ->
+                        failwithf
+                          (f_ "Section %s is only valid for the OASIS \
+                               plugin %s since v%s, but no plugin version is \
+                               defined in the _oasis file, change '%s' to \
+                               '%s (%s)' in your _oasis file.")
+                          sct plugin_name (string_of_version min_version)
+                          plugin_name
+                          plugin_name (string_of_version min_version)
+                with Not_found ->
+                  failwithf
+                    (f_ "Section %s is only valid when the OASIS plugin %s \
+                         is defined.")
+                    sct plugin_name
+              in
+              version_is_good ~min_version plugin_version_current
+                (f_ "Section %s is only valid for the OASIS plugin %s \
+                     since v%s, update your plugin from '%s (%s)' to \
+                     '%s (%s)' after checking the plugin's changelog.")
+                sct plugin_name (string_of_version min_version)
+                plugin_name (string_of_version plugin_version_current)
+                plugin_name (string_of_version min_version)
+            with Failure msg ->
+              Some msg
+          end
+
+      | NoOrigin, None, SinceVersion min_version ->
+          version_is_good ~min_version data.Data.oasis_version "%s" no_message
+
+      | NoOrigin, Some(plugin_knd, plugin_name, _), SinceVersion min_version ->
+          begin
+            try
+              let plugin_version_current =
+                match Data.plugin_version plugin_knd plugin_name data with
+                  | Some ver -> ver
+                  | None -> raise Not_found
+              in
+              version_is_good ~min_version plugin_version_current
+                "%s" no_message
+            with Not_found ->
+              Some no_message
+          end
+
+
+  let data_assert t data origin =
+    match data_check t data origin with
+      | None -> ()
+      | Some str -> failwith str
+
+
+  let data_test t data =
+    match data_check t data NoOrigin with
+      | None -> true
+      | Some str -> false
+
+
+  let package_test t pkg =
+    data_test t (Data.of_package pkg)
+
+
+  let create ?plugin name publication description =
+    let () =
+      if Hashtbl.mem all_features name then
+        failwithf "Feature '%s' is already declared." name
+    in
+    let t =
+      {
+        name = name;
+        plugin = plugin;
+        publication = publication;
+        description = description;
+      }
+    in
+      Hashtbl.add all_features name t;
+      t
+
+
+  let get_stage name =
+    try
+      (Hashtbl.find all_features name).publication
+    with Not_found ->
+      failwithf (f_ "Feature %s doesn't exist.") name
+
+
+  let list () =
+    Hashtbl.fold (fun _ v acc -> v :: acc) all_features []
+
+  (*
+   * Real flags.
+   *)
+
+
+  let features =
+    create "features_fields"
+      (since_version "0.4")
+      (fun () ->
+         s_ "Enable to experiment not yet official features.")
+
+
+  let flag_docs =
+    create "flag_docs"
+      (since_version "0.3")
+      (fun () ->
+         s_ "Building docs require '-docs' flag at configure.")
+
+
+  let flag_tests =
+    create "flag_tests"
+      (since_version "0.3")
+      (fun () ->
+         s_ "Running tests require '-tests' flag at configure.")
+
+
+  let pack =
+    create "pack"
+      (since_version "0.3")
+      (fun () ->
+         s_ "Allow to create packed library.")
+
+
+  let section_object =
+    create "section_object" beta
+      (fun () ->
+         s_ "Implement an object section.")
+
+
+  let dynrun_for_release =
+    create "dynrun_for_release" alpha
+      (fun () ->
+         s_ "Make '-setup-update dynamic' suitable for releasing project.")
 end
 
 module OASISUnixPath = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/oasis/OASISUnixPath.ml" *)
+(* # 22 "src/oasis/OASISUnixPath.ml" *)
+
 
   type unix_filename = string
   type unix_dirname = string
@@ -1260,7 +1740,7 @@
 end
 
 module OASISHostPath = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/oasis/OASISHostPath.ml" *)
+(* # 22 "src/oasis/OASISHostPath.ml" *)
 
 
   open Filename
@@ -1265,8 +1745,122 @@
 
   open Filename
 
+
   module Unix = OASISUnixPath
 
+  let bash_cmd = ref ( fun () -> "" )
+
+  let use_bash () = ( !bash_cmd () ) <> ""
+
+
+  (* generic quote and unixquote are taken from ocaml source *)
+  let generic_quote quotequote s =
+    let l = String.length s in
+    let b = Buffer.create (l + 20) in
+      Buffer.add_char b '\'';
+      for i = 0 to l - 1 do
+        if s.[i] = '\'' then
+          Buffer.add_string b quotequote
+        else
+          Buffer.add_char b  s.[i]
+      done;
+      Buffer.add_char b '\'';
+      Buffer.contents b
+
+  let unixquote = generic_quote "'\\''"
+
+  let win = Sys.os_type = "Win32"
+
+  let quote str =
+    if win && use_bash () then
+      unixquote str
+    else
+      quote str
+
+  (* uniform_path (only called, if Sys.os_type = "Win32")
+   * - enforces uniform path seperators
+   * - strips trailing slashes (exceptions in case of C:\ and / )
+   * - removes (some) unnecessary file components like ./././
+   *)
+
+  let get_naccu accu str first pos =
+    (* I assume c//d is identic to c/d
+     * the only exception (Network devices \\xyz\asdf)
+     * is covered in uniform_path
+     *)
+    if first = pos then
+      accu
+    else
+      let nlen = pos - first in
+      let nstr = String.sub str first nlen in
+        (* test/././ is the same as test *)
+        if nlen = 1 && nstr = "." then
+          accu
+        (* a/b/../ is the same as a *)
+        else if nlen = 2 && nstr = ".." then
+          match accu with
+            | []      -> [ nstr ]
+            | ".."::_ -> nstr::accu
+            | hd::tl  -> tl
+        else
+          nstr::accu
+
+  let is_path_sep = function
+    | '\\' | '/' -> true
+    | _ -> false
+
+
+  let uniform_path path_sep = function
+    | "" -> "" (* Raise an exception? Or an possible intermediate result?
+               * Filename.basename and dirname also don't raise exceptions *)
+    | str ->
+        let rec iter accu str len first pos =
+          if pos >= len then
+            List.rev (get_naccu accu str first pos)
+          else
+            let next = succ pos in
+              match is_path_sep str.[pos] with
+                | true -> iter (get_naccu accu str first pos) str len next next
+                | false -> iter accu str len first next
+        in
+          let is_unix_root = is_path_sep str.[0] in
+          let len = String.length str in
+          let next_sep = len > 1 && is_path_sep str.[1] in
+          let is_network_root = is_unix_root && next_sep in
+          let is_currel = str.[0] = '.' && ( next_sep || len = 1 ) in
+          let l = iter [] str len 0 0 in
+          (* Trailing slashes are normally stripped.
+           * This is not possible in case of root folders
+           * Sys.file_exists "C:" is false, Sys.file_exists "C:\\" true
+           *)
+          let l_min =
+            match l with
+              | [] -> [ "" ]
+              | _ -> l
+          in
+          let l =
+            if is_network_root then
+              ""::""::l_min
+            else if is_unix_root then
+              ""::l_min
+            else if is_currel then
+              "."::l
+            else
+              match l with
+                | s :: [] ->
+                    (* root folders like C:\ *)
+                    if String.length s = 2 && s.[1] = ':' &&
+                      len > 2 && is_path_sep str.[2]
+                    then
+                      s :: [ "" ]
+                    else
+                      l
+                | _ -> l
+          in
+            String.concat path_sep l
+
+
+
   let make =
     function
       | [] ->
@@ -1274,26 +1868,25 @@
       | hd :: tl ->
           List.fold_left Filename.concat hd tl
 
-  let of_unix ufn =
-    if Sys.os_type = "Unix" then
-      ufn
+
+  let of_unix str =
+    if win = false then
+      str
     else
-      make
-        (List.map
-           (fun p ->
-              if p = Unix.current_dir_name then
-                current_dir_name
-              else if p = Unix.parent_dir_name then
-                parent_dir_name
+      let path_sep =
+        if use_bash () then
+          "/"
               else
-                p)
-           (OASISString.nsplit ufn '/'))
+          "\\"
+      in
+        uniform_path path_sep str
 
 
 end
 
 module OASISSection = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/oasis/OASISSection.ml" *)
+(* # 22 "src/oasis/OASISSection.ml" *)
+
 
   open OASISTypes
 
@@ -1301,6 +1895,8 @@
     function
       | Library (cs, _, _) -> 
           `Library, cs
+      | Object (cs, _, _) ->
+          `Object, cs
       | Executable (cs, _, _) ->
           `Executable, cs
       | Flag (cs, _) ->
@@ -1318,6 +1916,7 @@
   let section_common_set cs =
     function
       | Library (_, bs, lib)     -> Library (cs, bs, lib)
+      | Object (_, bs, obj)      -> Object (cs, bs, obj)
       | Executable (_, bs, exec) -> Executable (cs, bs, exec)
       | Flag (_, flg)            -> Flag (cs, flg)
       | SrcRepo (_, src_repo)    -> SrcRepo (cs, src_repo)
@@ -1338,6 +1939,7 @@
     in
       (match k with
          | `Library    -> "library" 
+         | `Object     -> "object"
          | `Executable -> "executable"
          | `Flag       -> "flag"
          | `SrcRepo    -> "src repository"
@@ -1372,12 +1978,14 @@
 end
 
 module OASISBuildSection = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/oasis/OASISBuildSection.ml" *)
+(* # 22 "src/oasis/OASISBuildSection.ml" *)
+
 
 end
 
 module OASISExecutable = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/oasis/OASISExecutable.ml" *)
+(* # 22 "src/oasis/OASISExecutable.ml" *)
+
 
   open OASISTypes
 
@@ -1408,30 +2018,17 @@
 end
 
 module OASISLibrary = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/oasis/OASISLibrary.ml" *)
+(* # 22 "src/oasis/OASISLibrary.ml" *)
+
 
   open OASISTypes
   open OASISUtils
   open OASISGettext
   open OASISSection
 
-  type library_name = name
-  type findlib_part_name = name
-  type 'a map_of_findlib_part_name = 'a OASISUtils.MapString.t
-
-  exception InternalLibraryNotFound of library_name
-  exception FindlibPackageNotFound of findlib_name
-
-  type group_t =
-    | Container of findlib_name * group_t list
-    | Package of (findlib_name *
-                  common_section *
-                  build_section *
-                  library *
-                  group_t list)
 
   (* Look for a module file, considering capitalization or not. *)
-  let find_module source_file_exists (cs, bs, lib) modul =
+  let find_module source_file_exists bs modul =
     let possible_base_fn =
       List.map
         (OASISUnixPath.concat bs.bs_path)
@@ -1472,7 +2070,7 @@
   let source_unix_files ~ctxt (cs, bs, lib) source_file_exists =
     List.fold_left
       (fun acc modul ->
-         match find_module source_file_exists (cs, bs, lib) modul with
+         match find_module source_file_exists bs modul with
            | `Sources (base_fn, lst) ->
                (base_fn, lst) :: acc
            | `No_sources _ ->
@@ -1496,22 +2095,27 @@
 
     let find_modules lst ext = 
       let find_module modul =
-        match find_module source_file_exists (cs, bs, lib) modul with
+        match find_module source_file_exists bs modul with
+          | `Sources (base_fn, [fn]) when ext <> "cmi"
+                                       && Filename.check_suffix fn ".mli" ->
+              None (* No implementation files for pure interface. *)
           | `Sources (base_fn, _) ->
-              [base_fn]
+              Some [base_fn]
           | `No_sources lst ->
               OASISMessage.warning
                 ~ctxt
                 (f_ "Cannot find source file matching \
                      module '%s' in library %s")
                 modul cs.cs_name;
-              lst
+              Some lst
       in
-      List.map 
-        (fun nm -> 
-           List.map 
-             (fun base_fn -> base_fn ^"."^ext)
-             (find_module nm))
+      List.fold_left
+        (fun acc nm ->
+          match find_module nm with
+            | None -> acc
+            | Some base_fns ->
+                List.map (fun base_fn -> base_fn ^"."^ext) base_fns :: acc)
+        []
         lst
     in
 
@@ -1528,13 +2132,17 @@
     (* The .cmx that be compiled along *)
     let cmxs =
       let should_be_built =
-        (not lib.lib_pack) && (* Do not install .cmx packed submodules *)
         match bs.bs_compiled_object with
           | Native -> true
           | Best -> is_native
           | Byte -> false
       in
         if should_be_built then
+          if lib.lib_pack then
+            find_modules
+              [cs.cs_name]
+              "cmx"
+          else
           find_modules
             (lib.lib_modules @ lib.lib_internal_modules)
             "cmx"
@@ -1576,29 +2184,130 @@
               byte acc_nopath
     in
 
-    (* Add C library to be built *)
-    let acc_nopath =
-      if bs.bs_c_sources <> [] then
-        begin
-          ["lib"^cs.cs_name^"_stubs"^ext_lib]
-          ::
-          ["dll"^cs.cs_name^"_stubs"^ext_dll]
-          ::
-          acc_nopath
-        end
-      else
-        acc_nopath
-    in
+    (* Add C library to be built *)
+    let acc_nopath =
+      if bs.bs_c_sources <> [] then
+        begin
+          ["lib"^cs.cs_name^"_stubs"^ext_lib]
+          ::
+          ["dll"^cs.cs_name^"_stubs"^ext_dll]
+          ::
+          acc_nopath
+        end
+      else
+        acc_nopath
+    in
+
+      (* All the files generated *)
+      List.rev_append
+        (List.rev_map
+           (List.rev_map
+              (OASISUnixPath.concat bs.bs_path))
+           acc_nopath)
+        (headers @ cmxs)
+
+
+end
+
+module OASISObject = struct
+(* # 22 "src/oasis/OASISObject.ml" *)
+
+
+  open OASISTypes
+  open OASISGettext
+
+
+  let source_unix_files ~ctxt (cs, bs, obj) source_file_exists =
+    List.fold_left
+      (fun acc modul ->
+         match OASISLibrary.find_module source_file_exists bs modul with
+           | `Sources (base_fn, lst) ->
+               (base_fn, lst) :: acc
+           | `No_sources _ ->
+               OASISMessage.warning
+                 ~ctxt
+                 (f_ "Cannot find source file matching \
+                      module '%s' in object %s")
+                 modul cs.cs_name;
+               acc)
+      []
+      obj.obj_modules
+
+
+  let generated_unix_files
+        ~ctxt
+        ~is_native
+        ~source_file_exists
+        (cs, bs, obj) =
+
+    let find_module ext modul =
+      match OASISLibrary.find_module source_file_exists bs modul with
+        | `Sources (base_fn, _) -> [base_fn ^ ext]
+        | `No_sources lst ->
+          OASISMessage.warning
+            ~ctxt
+            (f_ "Cannot find source file matching \
+                 module '%s' in object %s")
+            modul cs.cs_name ;
+          lst
+    in
+
+    let header, byte, native, c_object, f =
+      match obj.obj_modules with
+        | [ m ] -> (find_module ".cmi" m,
+                    find_module ".cmo" m,
+                    find_module ".cmx" m,
+                    find_module ".o" m,
+                    fun x -> x)
+        | _ -> ([cs.cs_name ^ ".cmi"],
+                [cs.cs_name ^ ".cmo"],
+                [cs.cs_name ^ ".cmx"],
+                [cs.cs_name ^ ".o"],
+                OASISUnixPath.concat bs.bs_path)
+    in
+      List.map (List.map f) (
+        match bs.bs_compiled_object with
+          | Native ->
+              native :: c_object :: byte :: header :: []
+          | Best when is_native ->
+              native :: c_object :: byte :: header :: []
+          | Byte | Best ->
+              byte :: header :: [])
+
+
+end
+
+module OASISFindlib = struct
+(* # 22 "src/oasis/OASISFindlib.ml" *)
+
+
+  open OASISTypes
+  open OASISUtils
+  open OASISGettext
+  open OASISSection
+
+
+  type library_name = name
+  type findlib_part_name = name
+  type 'a map_of_findlib_part_name = 'a OASISUtils.MapString.t
+
+
+  exception InternalLibraryNotFound of library_name
+  exception FindlibPackageNotFound of findlib_name
+
+
+  type group_t =
+    | Container of findlib_name * group_t list
+    | Package of (findlib_name *
+                  common_section *
+                  build_section *
+                  [`Library of library | `Object of object_] *
+                  group_t list)
 
-      (* All the files generated *)
-      List.rev_append
-        (List.rev_map
-           (List.rev_map
-              (OASISUnixPath.concat bs.bs_path))
-           acc_nopath)
-        (headers @ cmxs)
 
-  type data = common_section * build_section * library
+  type data = common_section *
+              build_section *
+              [`Library of library | `Object of object_]
   type tree =
     | Node of (data option) * (tree MapString.t)
     | Leaf of data
@@ -1641,6 +2351,23 @@
                                mp
                    end
 
+               | Object (cs, _, obj) ->
+                   begin
+                     let obj_name = cs.cs_name in
+                     if MapString.mem obj_name mp then
+                       failwithf
+                         (f_ "The object name '%s' is used more than once.")
+                         obj_name;
+                     let findlib_full_name = match obj.obj_findlib_fullname with
+                       | Some ns -> String.concat "." ns
+                       | None -> obj_name
+                     in
+                     MapString.add
+                       obj_name
+                       (`Solved findlib_full_name)
+                       mp
+                   end
+
                | Executable _ | Test _ | Flag _ | SrcRepo _ | Doc _ ->
                    mp)
           MapString.empty
@@ -1708,7 +2435,7 @@
         let lib_name = cs.cs_name in
           findlib_name_of_library_name lib_name
       in
-      let rec add_children nm_lst (children : tree MapString.t) =
+      let rec add_children nm_lst (children: tree MapString.t) =
         match nm_lst with
           | (hd :: tl) ->
               begin
@@ -1778,7 +2505,9 @@
         (fun mp ->
            function
              | Library (cs, bs, lib) ->
-                 add (cs, bs, lib) mp
+                 add (cs, bs, `Library lib) mp
+             | Object (cs, bs, obj) ->
+                 add (cs, bs, `Object obj) mp
              | _ ->
                  mp)
         MapString.empty
@@ -1841,56 +2573,251 @@
 end
 
 module OASISFlag = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/oasis/OASISFlag.ml" *)
+(* # 22 "src/oasis/OASISFlag.ml" *)
+
 
 end
 
 module OASISPackage = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/oasis/OASISPackage.ml" *)
+(* # 22 "src/oasis/OASISPackage.ml" *)
+
 
 end
 
 module OASISSourceRepository = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/oasis/OASISSourceRepository.ml" *)
+(* # 22 "src/oasis/OASISSourceRepository.ml" *)
+
 
 end
 
 module OASISTest = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/oasis/OASISTest.ml" *)
+(* # 22 "src/oasis/OASISTest.ml" *)
+
 
 end
 
 module OASISDocument = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/oasis/OASISDocument.ml" *)
+(* # 22 "src/oasis/OASISDocument.ml" *)
+
 
 end
 
 module OASISExec = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/oasis/OASISExec.ml" *)
+(* # 22 "src/oasis/OASISExec.ml" *)
+
 
   open OASISGettext
   open OASISUtils
   open OASISMessage
 
+
+
+
+  (* In general, there is no chance to quote properly with the current
+   * settings. ( Note, that this is only a problem, if BaseCustom.run is
+   * used (e.g test commands, PreConfigure,....). Most of the time,
+   * OASISExec.run is used with enabled quoting.
+   *
+   * "$rm" should ideally expand to 'rm -f' (no quotes), but "$text_exec"
+   * should ideally expand to '"C:\Program Files\dir\test.exe"' (with
+   * quotes). Paths with spaces are common on Windows, so this problem
+   * can't be ignored.
+   *
+   * Using a command with additional parameters is quite useful, not only
+   * for trivial cases like $rm. You could add an additional parameter
+   * for $make in order to use a special compatibility mode, on windows
+   * you can use it to inform ocaml that a certain program is a shell
+   * script ('sh.exe pcre-config'), ...
+   *
+   * An additional parameter (e.g. $rm_switches) would be ugly,
+   * especially for *nix users, who don't use space characters in their
+   * installation paths anyway.
+   *
+   * Therefore, I use the following workaround which should work most of
+   * the time:
+   * - if cmd doesn't contains spaces or other suspicious characters, it
+   *   can be quoted in the usual way (not ambigous, I think)
+   * - if cmd does contain spaces, a file with this name exists, and the
+   *   beginning of cmd looks like a absolute pathname
+   *   ('\\test\dir\foo.exe' or "C:\\sa df\\foo.exe" - not "foo.exe" ), I
+   *   will also quote it. (ambigous, there could be "C:\bin\rm.exe" and
+   *   "C:\bin\rm -f.exe").  Relative filenames are not considered,
+   *   because I assume the source code folder contains only well named
+   *   files and relative paths like "../../make.exe" are uncommon
+   *   (autoconf even rejects them)
+   *)
+
+
+  (* stricter settings as for regular windows batch lines
+   * necessary because of shell comannds like:
+   *   LC_ALL=C make ....
+  *)
+  let is_dubious_char = function
+    | '~' | ':' | '.' | '-' | '_' | '/' | '\\' -> false
+    | c ->
+      OASISString.is_digit c = false &&
+      OASISString.is_alpha c = false
+
+
+  let win_quote_needed ~sep str =
+    String.length str = 0 ||
+    OASISString.exists ( fun c -> c = sep || c = '"' || OASISString.is_whitespace c ) str
+
+  let is_simple_command str =
+    String.length str > 0 &&
+    not (OASISString.exists is_dubious_char str)
+
+  let is_path_sep = function
+    | '/' | '\\' -> true
+    | _ -> false
+
+  let starts_with_absolute_path cmd =
+    let len = String.length cmd in
+      if len < 3 then
+        false
+      else
+        let c0 = cmd.[0] in
+        let c1 = cmd.[1] in
+          if is_path_sep c0 && is_path_sep c1 then (* network devices: "//" *)
+            true
+          else if len = 3 then
+            false
+          else  (* C:\.... *)
+            OASISString.is_alpha c0 && c1 = ':' && is_path_sep cmd.[2]
+
+  let exe_exts = lazy
+    begin
+      let exts =
+        try
+          OASISString.nsplit
+            (Sys.getenv "PATHEXT")
+            ';'
+        with
+          | Not_found -> []
+      in
+      let exts' =
+        List.filter
+          ( fun a -> a <> "" && a.[0] = '.' && a <> ".EXE" )
+          (List.map String.uppercase exts) (* windows file system doesn't care *)
+      in
+        ".EXE"::exts' (* .exe first, most common *)
+    end
+
+  let exe_file_exists fln =
+    Sys.file_exists fln ||
+    List.exists
+      (fun a -> Sys.file_exists ( fln ^ a ) )
+      (Lazy.force exe_exts)
+
+
+  let quote_anyway cmd =
+    if Sys.os_type <> "Win32" then (* workaround for windows only *)
+      false
+    else if is_simple_command cmd then
+      true
+    else
+      OASISString.exists OASISString.is_whitespace cmd &&
+        starts_with_absolute_path cmd &&
+        exe_file_exists cmd
+
+
+  let run_bash ~ctxt ?f_exit_code ?(quote=true) cmd args =
+    let fn = Filename.temp_file "oasis-" ".sh" in
+    let fn_deleted = ref false in
+      try
+        begin
+          let ch = open_out_bin fn in
+          let ch_closed = ref false in
+            try
+              begin
+                let cmd =
+                  if quote || quote_anyway cmd then
+                    OASISHostPath.quote (OASISHostPath.of_unix cmd)
+                  else
+                    cmd
+                in
+                  output_string ch cmd;
+                  List.iter
+                    ( fun s -> output_char ch ' '; output_string ch s )
+                    args ;
+                  output_char ch '\n';
+                  ch_closed:=true ;
+                  close_out ch;
+                  let bash = !OASISHostPath.bash_cmd () in
+                  let add_quotes = ref false in
+                  let shell_cmd =
+                    if Sys.os_type <> "Win32" then
+                      Filename.quote bash
+                    else
+                      if win_quote_needed ~sep:'\\' bash = false then
+                        bash
+                      else
+                        begin
+                          add_quotes := true;
+                          Filename.quote bash
+                        end
+                  in
+                  let cmdline_orig = String.concat " " (cmd :: args) in
+                  let cmdline =
+                    let s = shell_cmd ^ " " ^ (Filename.quote fn) in
+                      if !add_quotes then
+                        "\"" ^ s ^ "\""
+                      else
+                        s
+                  in
+                    info ~ctxt (f_ "Running command '%s'") cmdline_orig;
+                    let ret = Sys.command cmdline in
+                      fn_deleted := true;
+                      Sys.remove fn;
+                      match f_exit_code, ret with
+                        | None, 0 -> ()
+                        | None, i ->
+                            failwithf
+                              (f_ "Command '%s' terminated with error code %d")
+                              cmdline_orig i
+                        | Some f, i ->
+                            f i
+              end
+            with
+              | x when !ch_closed = false ->
+                  close_out_noerr ch;
+                  raise x
+        end
+      with
+        | x when !fn_deleted = false ->
+            (try Sys.remove fn with _ -> () ) ;
+            raise x
+
   (* TODO: I don't like this quote, it is there because $(rm) foo expands to
    * 'rm -f' foo...
    *)
-  let run ~ctxt ?f_exit_code ?(quote=true) cmd args =
+
+  let run_default ~ctxt ?f_exit_code ?(quote=true) cmd args =
+    let add_quotes = ref false in
     let cmd =
-      if quote then
+      if quote || quote_anyway cmd then
         if Sys.os_type = "Win32" then
-          if String.contains cmd ' ' then
-            (* Double the 1st double quote... win32... sigh *)
-            "\""^(Filename.quote cmd)
-          else
+          if win_quote_needed ~sep:'/' cmd = false then
             cmd
         else
+            begin
+              (* Double the 1st double quote... win32... sigh *)
+              (* Above comment ist false. The whole string must be quoted.
+               * However, an error is only triggered, if args contains also
+               * quoted parameters *)
+              add_quotes := true;
+              Filename.quote cmd
+            end
+        else
           Filename.quote cmd
       else
         cmd
     in
     let cmdline =
-      String.concat " " (cmd :: args)
+      let s = String.concat " " (cmd :: args) in
+        match !add_quotes with
+          | true -> "\"" ^ s ^ "\""
+          | false -> s
     in
       info ~ctxt (f_ "Running command '%s'") cmdline;
       match f_exit_code, Sys.command cmdline with
@@ -1902,6 +2829,14 @@
         | Some f, i ->
             f i
 
+
+
+  let run ~ctxt ?f_exit_code ?quote cmd args =
+    if OASISHostPath.use_bash () then
+      run_bash ~ctxt ?f_exit_code ?quote cmd args
+    else
+      run_default ~ctxt ?f_exit_code ?quote cmd args
+
   let run_read_output ~ctxt ?f_exit_code cmd args =
     let fn =
       Filename.temp_file "oasis-" ".txt"
@@ -1944,7 +2880,8 @@
 end
 
 module OASISFileUtil = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/oasis/OASISFileUtil.ml" *)
+(* # 22 "src/oasis/OASISFileUtil.ml" *)
+
 
   open OASISGettext
 
@@ -1969,7 +2908,7 @@
         (List.map
            (fun a ->
               List.map
-                (fun b -> a,b)
+                (fun b -> a, b)
                 lst2)
            lst1)
     in
@@ -1979,7 +2918,7 @@
         | p1 :: p2 :: tl ->
             let acc =
               (List.map
-                 (fun (a,b) -> Filename.concat a b)
+                 (fun (a, b) -> Filename.concat a b)
                  (p1 * p2))
             in
               combined_paths (acc :: tl)
@@ -1991,19 +2930,21 @@
 
     let alternatives =
       List.map
-        (fun (p,e) ->
+        (fun (p, e) ->
            if String.length e > 0 && e.[0] <> '.' then
              p ^ "." ^ e
            else
              p ^ e)
         ((combined_paths paths) * exts)
     in
-      List.find
+      List.find (fun file ->
         (if case_sensitive then
-           file_exists_case
+           file_exists_case file
          else
-           Sys.file_exists)
-        alternatives
+           Sys.file_exists file)
+        && not (Sys.is_directory file)
+      ) alternatives
+
 
   let which ~ctxt prg =
     let path_sep =
@@ -2021,7 +2962,11 @@
         | _ ->
             [""]
     in
+    let p =
       find_file ~case_sensitive:false [path_lst; [prg]] exec_ext
+    in
+      OASISHostPath.of_unix p
+
 
   (**/**)
   let rec fix_dir dn =
@@ -2036,9 +2981,11 @@
       else
         dn
 
-  let q = Filename.quote
+
+  let q s = OASISHostPath.quote (OASISHostPath.of_unix s)
   (**/**)
 
+
   let cp ~ctxt ?(recurse=false) src tgt =
     if recurse then
       match Sys.os_type with
@@ -2042,7 +2989,7 @@
   let cp ~ctxt ?(recurse=false) src tgt =
     if recurse then
       match Sys.os_type with
-        | "Win32" ->
+        | "Win32" when not (OASISHostPath.use_bash ()) ->
             OASISExec.run ~ctxt
               "xcopy" [q src; q tgt; "/E"]
         | _ ->
@@ -2050,18 +2997,22 @@
               "cp" ["-r"; q src; q tgt]
     else
       OASISExec.run ~ctxt
-        (match Sys.os_type with
-         | "Win32" -> "copy"
-         | _ -> "cp")
+        ( if Sys.os_type = "Win32" && not (OASISHostPath.use_bash ()) then
+            "copy"
+          else
+            "cp" )
         [q src; q tgt]
 
+
   let mkdir ~ctxt tgt =
     OASISExec.run ~ctxt
-      (match Sys.os_type with
-         | "Win32" -> "md"
-         | _ -> "mkdir")
+      ( if Sys.os_type = "Win32" && not (OASISHostPath.use_bash ()) then
+          "md"
+        else
+          "mkdir" )
       [q tgt]
 
+
   let rec mkdir_parent ~ctxt f tgt =
     let tgt =
       fix_dir tgt
@@ -2087,10 +3039,9 @@
   let rmdir ~ctxt tgt =
     if Sys.readdir tgt = [||] then
       begin
-        match Sys.os_type with
-          | "Win32" ->
+        if Sys.os_type = "Win32" && not (OASISHostPath.use_bash ()) then
               OASISExec.run ~ctxt "rd" [q tgt]
-          | _ ->
+        else
               OASISExec.run ~ctxt "rm" ["-r"; q tgt]
       end
 
@@ -2139,9 +3091,10 @@
 end
 
 
-# 2142 "setup.ml"
+# 3094 "setup.ml"
 module BaseEnvLight = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/base/BaseEnvLight.ml" *)
+(* # 22 "src/base/BaseEnvLight.ml" *)
+
 
   module MapString = Map.Make(String)
 
@@ -2237,9 +3195,10 @@
 end
 
 
-# 2240 "setup.ml"
+# 3198 "setup.ml"
 module BaseContext = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/base/BaseContext.ml" *)
+(* # 22 "src/base/BaseContext.ml" *)
+
 
   open OASISContext
 
@@ -2250,7 +3211,8 @@
 end
 
 module BaseMessage = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/base/BaseMessage.ml" *)
+(* # 22 "src/base/BaseMessage.ml" *)
+
 
   (** Message to user, overrid for Base
       @author Sylvain Le Gall
@@ -2269,7 +3235,7 @@
 end
 
 module BaseEnv = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/base/BaseEnv.ml" *)
+(* # 22 "src/base/BaseEnv.ml" *)
 
   open OASISGettext
   open OASISUtils
@@ -2314,7 +3288,8 @@
   let var_lxr =
     Genlex.make_lexer []
 
-  let rec var_expand str =
+
+  let rec var_expand ?(quoted=false) str =
     let buff =
       Buffer.create ((String.length str) * 2)
     in
@@ -2342,7 +3317,11 @@
                  | [Genlex.Ident "ocaml_escaped"; Genlex.String s] ->
                      String.escaped s
                  | [Genlex.Ident nm] ->
-                     var_get nm
+                     let s = var_get nm in
+                     if quoted then
+                       OASISHostPath.quote s
+                     else
+                       s
                  | _ ->
                      failwithf
                        (f_ "Unknown expression '%s' in variable expansion of %s.")
@@ -2509,8 +3493,9 @@
           dflt
       end
 
-  let var_ignore (e : unit -> string) =
-    ()
+
+  let var_ignore (e: unit -> string) = ()
+
 
   let print_hidden =
     var_define
@@ -2614,7 +3605,7 @@
 
     Printf.printf "\nConfiguration: \n";
     List.iter
-      (fun (name,value) ->
+      (fun (name, value) ->
         Printf.printf "%s: %s %s\n" name (dot_pad name) value)
       (List.rev printable_vars);
     Printf.printf "\n%!"
@@ -2729,7 +3721,8 @@
 end
 
 module BaseArgExt = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/base/BaseArgExt.ml" *)
+(* # 22 "src/base/BaseArgExt.ml" *)
+
 
   open OASISUtils
   open OASISGettext
@@ -2757,7 +3751,8 @@
 end
 
 module BaseCheck = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/base/BaseCheck.ml" *)
+(* # 22 "src/base/BaseCheck.ml" *)
+
 
   open BaseEnv
   open BaseMessage
@@ -2849,12 +3851,24 @@
     in
     let findlib_dir pkg =
       let dir =
-        OASISExec.run_read_one_line ~ctxt:!BaseContext.default
+        let d = OASISExec.run_read_one_line ~ctxt:!BaseContext.default
           (ocamlfind ())
           ["query"; "-format"; "%d"; pkg]
       in
+        (* Win32/Cygwin only:
+         * The output of this command is possibly quoted, but not with Filename.quote
+         * see findlib's src/findlib/frontend.ml for details
+         *)
+        let l = String.length d in
+          if l > 2 && d.[0] = '"' && d.[l - 1] = '"' &&
+            ( Sys.os_type = "Win32" || Sys.os_type = "Cygwin" ) &&
+            String.contains d ' ' then
+            String.sub d 1 (l - 2)
+          else
+            d
+      in
         if Sys.file_exists dir && Sys.is_directory dir then
-          dir
+          OASISHostPath.of_unix dir
         else
           failwithf
             (f_ "When looking for findlib package %s, \
@@ -2883,7 +3897,7 @@
 end
 
 module BaseOCamlcConfig = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/base/BaseOCamlcConfig.ml" *)
+(* # 22 "src/base/BaseOCamlcConfig.ml" *)
 
 
   open BaseEnv
@@ -2977,6 +3995,9 @@
       match nm with
         | "ocaml_version" -> 
             "version", chop_version_suffix
+        | "standard_library"
+        | "standard_library_default" ->
+            nm, ( fun x -> OASISHostPath.of_unix x)
         | _ -> nm, (fun x -> x)
     in
       var_redefine
@@ -2999,7 +4020,7 @@
 end
 
 module BaseStandardVar = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/base/BaseStandardVar.ml" *)
+(* # 22 "src/base/BaseStandardVar.ml" *)
 
 
   open OASISGettext
@@ -3101,26 +4136,60 @@
       name
       dflt
 
+
   let (/) a b =
-    if os_type () = Sys.os_type then
+    let os = os_type () in
+    if os = Sys.os_type then
+      if Sys.os_type = "Win32" && OASISHostPath.use_bash () then
+        OASISUnixPath.concat a b
+      else
       Filename.concat a b
-    else if os_type () = "Unix" then
+    else if os = "Unix" then
       OASISUnixPath.concat a b
     else
       OASISUtils.failwithf (f_ "Cannot handle os_type %s filename concat")
         (os_type ())
   (**/**)
 
+  let bash_cmd =
+    var_define
+      ~short_desc:(fun () -> s_ "Enforced bash shell:")
+      ~cli:CLIAuto
+      ~arg_help:"program"
+      "use_bash"
+      (fun () -> if Sys.os_type = "Win32" then "bash.exe" else "")
+
+
   let prefix =
     p "prefix"
       (fun () -> s_ "Install architecture-independent files dir")
       (fun () ->
          match os_type () with
            | "Win32" ->
+               let getenv w =
+                 try
+                   Some(Sys.getenv w)
+                 with
+                 | Not_found -> None
+               in
+               let s =
+                 if Sys.word_size = 64 then
+                   getenv "ProgramW6432"
+                 else
+                   None
+               in
+               let s =
+                 if s = None then
+                   getenv "PROGRAMFILES"
+                 else
+                   s
+               in
                let program_files =
-                 Sys.getenv "PROGRAMFILES"
+                 match s with
+                   | None -> "C:\\Program Files"
+                   | Some x -> x
                in
-                 program_files/(pkg_name ())
+                 OASISHostPath.of_unix (program_files/(pkg_name ()))
            | _ ->
                "/usr/local")
 
@@ -3192,7 +4275,16 @@
   let docdir =
     p "docdir"
       (fun () -> s_ "Documentation root")
-      (fun () -> "$datarootdir"/"doc"/"$pkg_name")
+      (fun () ->
+        (* TODO: (Windows only?) "$pkg_name" is not always substituted
+         * (at least if datarootdir contains spaces or other garbage)
+         * I haven't looked up why.
+         *)
+        match os_type () with
+        | "Win32" -> "$datarootdir"/"doc"/ ( pkg_name () )
+        | _ -> "$datarootdir"/"doc"/"$pkg_name"
+      )
+
 
   let htmldir =
     p "htmldir"
@@ -3234,12 +4332,12 @@
       "is_native"
       (fun () ->
          try
-           let _s : string =
+           let _s: string =
              ocamlopt ()
            in
              "true"
          with PropList.Not_set _ ->
-           let _s : string =
+           let _s: string =
              ocamlc ()
            in
              "false")
@@ -3249,9 +4348,10 @@
       "suffix_program"
       (fun () ->
          match os_type () with
-           | "Win32" -> ".exe"
+           | "Win32" | "Cygwin" -> ".exe"
            | _ -> "")
 
+
   let rm =
     var_define
       ~short_desc:(fun () -> s_ "Remove a file.")
@@ -3257,18 +4357,22 @@
       ~short_desc:(fun () -> s_ "Remove a file.")
       "rm"
       (fun () ->
-         match os_type () with
-           | "Win32" -> "del"
-           | _ -> "rm -f")
+         if not (OASISHostPath.use_bash ()) && os_type () = "Win32" then
+           "del"
+         else
+           "rm -f" )
+
 
   let rmdir =
     var_define
       ~short_desc:(fun () -> s_ "Remove a directory.")
       "rmdir"
       (fun () ->
-         match os_type () with
-           | "Win32" -> "rd"
-           | _ -> "rm -rf")
+         if not (OASISHostPath.use_bash ()) && os_type () = "Win32" then
+           "rd"
+         else
+           "rm -rf")
+
 
   let debug =
     var_define
@@ -3360,10 +4469,13 @@
     rpkg := Some pkg;
     List.iter (fun f -> f pkg.oasis_version) !var_cond
 
+  let () =
+    OASISHostPath.bash_cmd := bash_cmd
 end
 
 module BaseFileAB = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/base/BaseFileAB.ml" *)
+(* # 22 "src/base/BaseFileAB.ml" *)
+
 
   open BaseEnv
   open OASISGettext
@@ -3411,7 +4525,8 @@
 end
 
 module BaseLog = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/base/BaseLog.ml" *)
+(* # 22 "src/base/BaseLog.ml" *)
+
 
   open OASISUtils
 
@@ -3530,7 +4652,8 @@
 end
 
 module BaseBuilt = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/base/BaseBuilt.ml" *)
+(* # 22 "src/base/BaseBuilt.ml" *)
+
 
   open OASISTypes
   open OASISGettext
@@ -3541,8 +4665,10 @@
     | BExec    (* Executable *)
     | BExecLib (* Library coming with executable *)
     | BLib     (* Library *)
+    | BObj     (* Library *)
     | BDoc     (* Document *)
 
+
   let to_log_event_file t nm =
     "built_"^
     (match t with
@@ -3549,6 +4675,7 @@
        | BExec -> "exec"
        | BExecLib -> "exec_lib"
        | BLib -> "lib"
+       | BObj -> "obj"
        | BDoc -> "doc")^
     "_"^nm
 
@@ -3612,6 +4743,8 @@
                          (f_ "executable %s")
                      | BLib ->
                          (f_ "library %s")
+                     | BObj ->
+                         (f_ "object %s")
                      | BDoc ->
                          (f_ "documentation %s"))
                   nm);
@@ -3674,10 +4810,28 @@
     in
       evs, unix_lst
 
+
+  let of_object ffn (cs, bs, obj) =
+    let unix_lst =
+      OASISObject.generated_unix_files
+        ~ctxt:!BaseContext.default
+        ~source_file_exists:(fun fn ->
+           OASISFileUtil.file_exists_case (OASISHostPath.of_unix fn))
+        ~is_native:(bool_of_string (is_native ()))
+        (cs, bs, obj)
+    in
+    let evs =
+      [BObj,
+       cs.cs_name,
+       List.map (List.map ffn) unix_lst]
+    in
+      evs, unix_lst
+
 end
 
 module BaseCustom = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/base/BaseCustom.ml" *)
+(* # 22 "src/base/BaseCustom.ml" *)
+
 
   open BaseEnv
   open BaseMessage
@@ -3688,9 +4843,10 @@
     OASISExec.run ~ctxt:!BaseContext.default ~quote:false
       (var_expand cmd)
       (List.map
-         var_expand
+         (var_expand ~quoted:true)
          (args @ (Array.to_list extra_args)))
 
+
   let hook ?(failsafe=false) cstm f e =
     let optional_command lst =
       let printer =
@@ -3727,7 +4883,7 @@
 end
 
 module BaseDynVar = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/base/BaseDynVar.ml" *)
+(* # 22 "src/base/BaseDynVar.ml" *)
 
 
   open OASISTypes
@@ -3768,13 +4925,14 @@
                                              (f_ "Executable '%s' not yet built.")
                                              cs.cs_name)))))
 
-         | Library _ | Flag _ | Test _ | SrcRepo _ | Doc _ ->
+         | Library _ | Object _ | Flag _ | Test _ | SrcRepo _ | Doc _ ->
              ())
       pkg.sections
 end
 
 module BaseTest = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/base/BaseTest.ml" *)
+(* # 22 "src/base/BaseTest.ml" *)
+
 
   open BaseEnv
   open BaseMessage
@@ -3832,7 +4991,7 @@
           (failure, n)
         end
     in
-    let (failed, n) =
+    let failed, n =
       List.fold_left
         one_test
         (0.0, 0)
@@ -3855,7 +5014,7 @@
         info "%s" msg;
 
       (* Possible explanation why the tests where not run. *)
-      if OASISVersion.version_0_3_or_after pkg.oasis_version &&
+      if OASISFeatures.package_test OASISFeatures.flag_tests pkg &&
          not (bool_of_string (BaseStandardVar.tests ())) &&
          lst <> [] then
         BaseMessage.warning
@@ -3864,7 +5023,8 @@
 end
 
 module BaseDoc = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/base/BaseDoc.ml" *)
+(* # 22 "src/base/BaseDoc.ml" *)
+
 
   open BaseEnv
   open BaseMessage
@@ -3890,7 +5051,7 @@
     in
       List.iter one_doc lst;
 
-      if OASISVersion.version_0_3_or_after pkg.oasis_version &&
+      if OASISFeatures.package_test OASISFeatures.flag_docs pkg &&
          not (bool_of_string (BaseStandardVar.docs ())) &&
          lst <> [] then
         BaseMessage.warning
@@ -3899,7 +5060,7 @@
 end
 
 module BaseSetup = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/base/BaseSetup.ml" *)
+(* # 22 "src/base/BaseSetup.ml" *)
 
   open BaseEnv
   open BaseMessage
@@ -3961,11 +5127,22 @@
         nm
         action
 
+
   let configure t args =
     (* Run configure *)
+
+    let rec f = function
+      | [] -> ()
+      | "--use-bash"::x::_ ->
+          OASISHostPath.bash_cmd := (fun () -> x);
+      | _::tl -> f tl
+    in
+      (* use-bash is an exception. It's already needed to run the pre-configure script *)
+      f (Array.to_list args);
     BaseCustom.hook
       t.package.conf_custom
       (fun () -> 
+           OASISHostPath.bash_cmd := BaseStandardVar.bash_cmd;
          (* Reload if preconf has changed it *)
          begin
            try
@@ -4043,6 +5224,9 @@
     let rno_test =
       ref false
     in
+    let arg_rest =
+      ref []
+    in
       Arg.parse_argv
         ~current:(ref 0)
         (Array.of_list
@@ -4056,12 +5240,16 @@
           "-no-test",
           Arg.Set rno_test,
           s_ "Don't run test target";
+
+          "--",
+          Arg.Rest (fun arg -> arg_rest := arg :: !arg_rest),
+          s_ "All arguments for configure.";
         ]
         (failwithf (f_ "Don't know what to do with '%s'"))
         "";
 
       info "Running configure step";
-      configure t [||];
+      configure t (Array.of_list (List.rev !arg_rest));
 
       info "Running build step";
       build     t [||];
@@ -4146,6 +5338,7 @@
                         (f t.package (cs, doc))
                         args
                 | Library _
+                | Object _
                 | Executable _
                 | Flag _
                 | SrcRepo _ ->
@@ -4477,9 +5675,10 @@
 end
 
 
-# 4480 "setup.ml"
+# 5678 "setup.ml"
 module InternalConfigurePlugin = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/plugins/internal/InternalConfigurePlugin.ml" *)
+(* # 22 "src/plugins/internal/InternalConfigurePlugin.ml" *)
+
 
   (** Configure using internal scheme
       @author Sylvain Le Gall
@@ -4495,20 +5696,9 @@
     * and then output corresponding file.
     *)
   let configure pkg argv =
-    let var_ignore_eval var =
-      let _s : string =
-        var ()
-      in
-        ()
-    in
-
-    let errors =
-      ref SetString.empty
-    in
-
-    let buff =
-      Buffer.create 13
-    in
+    let var_ignore_eval var = let _s: string = var () in () in
+    let errors = ref SetString.empty in
+    let buff = Buffer.create 13 in
 
     let add_errors fmt =
       Printf.kbprintf
@@ -4656,6 +5846,20 @@
         | None ->
             ()
     end;
+    (* Make sure the findlib version is fine for the OCaml compiler. *)
+    begin
+      let ocaml_ge4 =
+        OASISVersion.version_compare
+          (OASISVersion.version_of_string (BaseStandardVar.ocaml_version()))
+          (OASISVersion.version_of_string "4.0.0") >= 0 in
+      if ocaml_ge4 then
+        let findlib_lt132 =
+          OASISVersion.version_compare
+            (OASISVersion.version_of_string (BaseStandardVar.findlib_version()))
+            (OASISVersion.version_of_string "1.3.2") < 0 in
+        if findlib_lt132 then
+          add_errors "OCaml >= 4.0.0 requires Findlib version >= 1.3.2"
+    end;
 
     (* FlexDLL *)
     if BaseStandardVar.os_type () = "Win32" ||
@@ -4721,7 +5926,8 @@
 end
 
 module InternalInstallPlugin = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/plugins/internal/InternalInstallPlugin.ml" *)
+(* # 22 "src/plugins/internal/InternalInstallPlugin.ml" *)
+
 
   (** Install using internal scheme
       @author Sylvain Le Gall
@@ -4731,7 +5938,7 @@
   open BaseStandardVar
   open BaseMessage
   open OASISTypes
-  open OASISLibrary
+  open OASISFindlib
   open OASISGettext
   open OASISUtils
 
@@ -4741,6 +5950,11 @@
   let lib_hook =
     ref (fun (cs, bs, lib) -> cs, bs, lib, [])
 
+
+  let obj_hook =
+    ref (fun (cs, bs, obj) -> cs, bs, obj, [])
+
+
   let doc_hook =
     ref (fun (cs, doc) -> cs, doc)
 
@@ -4753,10 +5970,20 @@
   let install_findlib_ev =
     "install-findlib"
 
-  let win32_max_command_line_length = 8000
 
   let split_install_command ocamlfind findlib_name meta files =
     if Sys.os_type = "Win32" then
+      let f s =
+        OASISHostPath.quote ( OASISHostPath.of_unix s )
+      in
+      let files = List.map f files in
+      let meta = f meta  in
+      let win32_max_command_line_length =
+        if OASISHostPath.use_bash () = false then
+          8000
+        else
+          30000
+      in
       (* Arguments for the first command: *)
       let first_args = ["install"; findlib_name; meta] in
       (* Arguments for remaining commands: *)
@@ -4804,10 +6031,11 @@
                       in
                         if not findlib_ge_132 then
                           failwithf
-                            (f_ "Installing the library %s require to use the flag \
-                                 '-add' of ocamlfind because the command line is too \
-                                  long. This flag is only available for findlib 1.3.2. \
-                                  Please upgrade findlib from %s to 1.3.2")
+                            (f_ "Installing the library %s require to use the \
+                                 flag '-add' of ocamlfind because the command \
+                                 line is too long. This flag is only available \
+                                 for findlib 1.3.2. Please upgrade findlib from \
+                                 %s to 1.3.2")
                             findlib_name (BaseStandardVar.findlib_version ())
                     in
                     let cmds = split other_args others in
@@ -4961,6 +6190,75 @@
             begin
               (f_data, acc)
             end
+      and files_of_object (f_data, acc) data_obj =
+        let cs, bs, obj, obj_extra =
+          !obj_hook data_obj
+        in
+          if var_choose bs.bs_install &&
+             BaseBuilt.is_built BaseBuilt.BObj cs.cs_name then
+            begin
+              let acc =
+                (* Start with acc + obj_extra *)
+                List.rev_append obj_extra acc
+              in
+              let acc =
+                (* Add uncompiled header from the source tree *)
+                let path =
+                  OASISHostPath.of_unix bs.bs_path
+                in
+                  List.fold_left
+                    (fun acc modul ->
+                       try
+                         List.find
+                           OASISFileUtil.file_exists_case
+                           (List.map
+                              (Filename.concat path)
+                              [modul^".mli";
+                               modul^".ml";
+                               String.uncapitalize modul^".mli";
+                               String.capitalize   modul^".mli";
+                               String.uncapitalize modul^".ml";
+                               String.capitalize   modul^".ml"])
+                         :: acc
+                       with Not_found ->
+                         begin
+                           warning
+                             (f_ "Cannot find source header for module %s \
+                                  in object %s")
+                             modul cs.cs_name;
+                           acc
+                         end)
+                    acc
+                    obj.obj_modules
+              in
+
+              let acc =
+               (* Get generated files *)
+               BaseBuilt.fold
+                 BaseBuilt.BObj
+                 cs.cs_name
+                 (fun acc fn -> fn :: acc)
+                 acc
+              in
+
+              let f_data () =
+                (* Install data associated with the object *)
+                install_data
+                  bs.bs_path
+                  bs.bs_data_files
+                  (Filename.concat
+                     (datarootdir ())
+                     pkg.name);
+                f_data ()
+              in
+
+                (f_data, acc)
+            end
+           else
+            begin
+              (f_data, acc)
+            end
+
       in
 
       (* Install one group of library *)
@@ -4971,8 +6269,10 @@
             match grp with
               | Container (_, children) ->
                   data_and_files, children
-              | Package (_, cs, bs, lib, children) ->
+              | Package (_, cs, bs, `Library lib, children) ->
                   files_of_library data_and_files (cs, bs, lib), children
+              | Package (_, cs, bs, `Object obj, children) ->
+                  files_of_object data_and_files (cs, bs, obj), children
           in
             List.fold_left
               install_group_lib_aux
@@ -5006,7 +6306,7 @@
             begin
               let meta =
                 (* Search META file *)
-                let (_, bs, _) =
+                let _, bs, _ =
                   root_lib
                 in
                 let res =
@@ -5079,7 +6379,7 @@
 
     let install_execs pkg =
       let install_exec data_exec =
-        let (cs, bs, exec) =
+        let cs, bs, exec =
           !exec_hook data_exec
         in
           if var_choose bs.bs_install &&
@@ -5126,7 +6426,7 @@
 
     let install_docs pkg =
       let install_doc data =
-        let (cs, doc) =
+        let cs, doc =
           !doc_hook data
         in
           if var_choose doc.doc_install &&
@@ -5225,14 +6526,16 @@
          (BaseLog.filter
             [install_file_ev;
              install_dir_ev;
-             install_findlib_ev;]))
+             install_findlib_ev]))
+
 
 end
 
 
-# 5233 "setup.ml"
+# 6535 "setup.ml"
 module OCamlbuildCommon = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/plugins/ocamlbuild/OCamlbuildCommon.ml" *)
+(* # 22 "src/plugins/ocamlbuild/OCamlbuildCommon.ml" *)
+
 
   (** Functions common to OCamlbuild build and doc plugin
     *)
@@ -5260,7 +6567,7 @@
             "-no-log";
             "-no-links";
             "-install-lib-dir";
-            (Filename.concat (standard_library ()) "ocamlbuild")
+            (OASISHostPath.quote (OASISHostPath.of_unix (Filename.concat (standard_library ()) "ocamlbuild")))
           ]
         else
           [];
@@ -5334,7 +6645,8 @@
 end
 
 module OCamlbuildPlugin = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/plugins/ocamlbuild/OCamlbuildPlugin.ml" *)
+(* # 22 "src/plugins/ocamlbuild/OCamlbuildPlugin.ml" *)
+
 
   (** Build using ocamlbuild
       @author Sylvain Le Gall
@@ -5343,6 +6656,7 @@
   open OASISTypes
   open OASISGettext
   open OASISUtils
+  open OASISString
   open BaseEnv
   open OCamlbuildCommon
   open BaseStandardVar
@@ -5351,8 +6669,28 @@
   let cond_targets_hook =
     ref (fun lst -> lst)
 
-  let build pkg argv =
 
+  type ocamlbuild_plugin =
+    {
+      plugin_tags: string option;
+      extra_args: string list;
+    }
+
+
+  let check_ocaml_version version pkg =
+    match pkg.ocaml_version with
+      | Some ocaml_version ->
+          let min_ocaml_version = OASISVersion.version_of_string version in
+          OASISVersion.comparator_ge min_ocaml_version ocaml_version
+      | None ->
+          false
+
+
+  let ocamlbuild_supports_ocamlfind = check_ocaml_version "3.12.1"
+  let ocamlbuild_supports_plugin_tags = check_ocaml_version "4.01"
+
+
+  let build t pkg argv =
     (* Return the filename in build directory *)
     let in_build_dir fn =
       Filename.concat
@@ -5377,16 +6715,36 @@
                        (cs, bs, lib)
                    in
 
-                   let ends_with nd fn =
-                     let nd_len =
-                       String.length nd
-                     in
-                       (String.length fn >= nd_len)
-                       &&
-                       (String.sub
-                          fn
-                          (String.length fn - nd_len)
-                          nd_len) = nd
+                   let tgts =
+                     List.flatten
+                       (List.filter
+                          (fun l -> l <> [])
+                          (List.map
+                             (List.filter
+                                (fun fn ->
+                                 ends_with ~what:".cma" fn
+                                 || ends_with ~what:".cmxs" fn
+                                 || ends_with ~what:".cmxa" fn
+                                 || ends_with ~what:(ext_lib ()) fn
+                                 || ends_with ~what:(ext_dll ()) fn))
+                             unix_files))
+                   in
+
+                     match tgts with
+                       | _ :: _ ->
+                           (evs, tgts) :: acc
+                       | [] ->
+                           failwithf
+                             (f_ "No possible ocamlbuild targets for library %s")
+                             cs.cs_name
+                 end
+
+             | Object (cs, bs, obj) when var_choose bs.bs_build ->
+                 begin
+                   let evs, unix_files =
+                     BaseBuilt.of_object
+                       in_build_dir_of_unix
+                       (cs, bs, obj)
                    in
 
                    let tgts =
@@ -5396,11 +6754,8 @@
                           (List.map
                              (List.filter
                                 (fun fn ->
-                                 ends_with ".cma" fn
-                                 || ends_with ".cmxs" fn
-                                 || ends_with ".cmxa" fn
-                                 || ends_with (ext_lib ()) fn
-                                 || ends_with (ext_dll ()) fn))
+                                 ends_with ".cmo" fn
+                                 || ends_with ".cmx" fn))
                              unix_files))
                    in
 
@@ -5409,7 +6764,7 @@
                            (evs, tgts) :: acc
                        | [] ->
                            failwithf
-                             (f_ "No possible ocamlbuild targets for library %s")
+                             (f_ "No possible ocamlbuild targets for object %s")
                              cs.cs_name
                  end
 
@@ -5433,7 +6788,8 @@
                        List.map
                          (function
                             | BaseBuilt.BExec, nm, lst when nm = cs.cs_name ->
-                                BaseBuilt.BExec, nm, [[in_build_dir_of_unix unix_tgt]]
+                                BaseBuilt.BExec, nm,
+                                [[in_build_dir_of_unix unix_tgt]]
                             | ev ->
                                 ev)
                          evs
@@ -5455,7 +6811,7 @@
                      acc
                  end
 
-             | Library _ | Executable _ | Test _
+             | Library _ | Object _ | Executable _ | Test _
              | SrcRepo _ | Flag _ | Doc _ ->
                  acc)
         []
@@ -5469,8 +6825,11 @@
         (fun fns ->
            if not (List.exists OASISFileUtil.file_exists_case fns) then
              failwithf
-               (f_ "No one of expected built files %s exists")
-               (String.concat (s_ ", ") (List.map (Printf.sprintf "'%s'") fns)))
+               (fn_
+                  "Expected built file %s doesn't exist."
+                  "None of expected built files %s exists."
+                  (List.length fns))
+               (String.concat (s_ " or ") (List.map (Printf.sprintf "'%s'") fns)))
         lst;
         (BaseBuilt.register bt bnm lst)
     in
@@ -5480,10 +6839,23 @@
       !cond_targets_hook cond_targets
     in
 
+    let extra_args =
+      match t.plugin_tags with
+        | Some tags -> "-plugin-tags" :: ("'" ^ tags ^ "'") :: t.extra_args
+        | None -> t.extra_args
+    in
+    let extra_args =
+      if ocamlbuild_supports_ocamlfind pkg then
+        "-use-ocamlfind" :: extra_args
+      else
+        extra_args
+    in
+
       (* Run a list of target... *)
       run_ocamlbuild 
         (List.flatten 
-           (List.map snd cond_targets))
+           (List.map snd cond_targets)
+         @ extra_args)
         argv;
       (* ... and register events *)
       List.iter
@@ -5507,7 +6880,8 @@
 end
 
 module OCamlbuildDocPlugin = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/plugins/ocamlbuild/OCamlbuildDocPlugin.ml" *)
+(* # 22 "src/plugins/ocamlbuild/OCamlbuildDocPlugin.ml" *)
+
 
   (* Create documentation using ocamlbuild .odocl files
      @author Sylvain Le Gall
@@ -5555,9 +6934,10 @@
 end
 
 
-# 5558 "setup.ml"
+# 6937 "setup.ml"
 module CustomPlugin = struct
-(* # 21 "/home/andre/src/oasis-0.3.0/src/plugins/custom/CustomPlugin.ml" *)
+(* # 22 "src/plugins/custom/CustomPlugin.ml" *)
+
 
   (** Generate custom configure/build/doc/test/install system
       @author
@@ -5691,13 +7082,15 @@
 end
 
 
-# 5694 "setup.ml"
+# 7085 "setup.ml"
 open OASISTypes;;
 
 let setup_t =
   {
      BaseSetup.configure = InternalConfigurePlugin.configure;
-     build = OCamlbuildPlugin.build;
+     build =
+       OCamlbuildPlugin.build
+         {OCamlbuildPlugin.plugin_tags = None; extra_args = []};
      test = [];
      doc = [];
      install =
@@ -5709,7 +7102,7 @@
                    ("EXEC_PREFIX=$exec_prefix", ["make"; "install"]))
               ];
             cmd_clean = [(OASISExpr.EBool true, None)];
-            cmd_distclean = [(OASISExpr.EBool true, None)];
+            cmd_distclean = [(OASISExpr.EBool true, None)]
             };
      uninstall =
        CustomPlugin.main
@@ -5717,7 +7110,7 @@
             CustomPlugin.cmd_main =
               [(OASISExpr.EBool true, ("make", ["uninstall"]))];
             cmd_clean = [(OASISExpr.EBool true, None)];
-            cmd_distclean = [(OASISExpr.EBool true, None)];
+            cmd_distclean = [(OASISExpr.EBool true, None)]
             };
      clean =
        [
@@ -5730,14 +7123,14 @@
                       ("EXEC_PREFIX=$exec_prefix", ["make"; "install"]))
                  ];
                cmd_clean = [(OASISExpr.EBool true, None)];
-               cmd_distclean = [(OASISExpr.EBool true, None)];
+               cmd_distclean = [(OASISExpr.EBool true, None)]
                };
           CustomPlugin.clean
             {
                CustomPlugin.cmd_main =
                  [(OASISExpr.EBool true, ("make", ["uninstall"]))];
                cmd_clean = [(OASISExpr.EBool true, None)];
-               cmd_distclean = [(OASISExpr.EBool true, None)];
+               cmd_distclean = [(OASISExpr.EBool true, None)]
                }
        ];
      clean_test = [];
@@ -5752,14 +7145,14 @@
                       ("EXEC_PREFIX=$exec_prefix", ["make"; "install"]))
                  ];
                cmd_clean = [(OASISExpr.EBool true, None)];
-               cmd_distclean = [(OASISExpr.EBool true, None)];
+               cmd_distclean = [(OASISExpr.EBool true, None)]
                };
           CustomPlugin.distclean
             {
                CustomPlugin.cmd_main =
                  [(OASISExpr.EBool true, ("make", ["uninstall"]))];
                cmd_clean = [(OASISExpr.EBool true, None)];
-               cmd_distclean = [(OASISExpr.EBool true, None)];
+               cmd_distclean = [(OASISExpr.EBool true, None)]
                }
        ];
      distclean_test = [];
@@ -5769,6 +7162,8 @@
           oasis_version = "0.3";
           ocaml_version = None;
           findlib_version = None;
+          alpha_features = [];
+          beta_features = [];
           name = "ospec";
           version = "0.3.1";
           license =
@@ -5777,7 +7172,7 @@
                  {
                     OASISLicense.license = "MIT";
                     excption = None;
-                    version = OASISLicense.NoVersion;
+                    version = OASISLicense.NoVersion
                     });
           license_file = Some "LICENSE";
           copyrights = [];
@@ -5787,38 +7182,38 @@
           synopsis = "BDD for OCaml";
           description = None;
           categories = [];
-          conf_type = (`Configure, "internal", Some "0.3");
+          conf_type = (`Configure, "internal", Some "0.4");
           conf_custom =
             {
                pre_command = [(OASISExpr.EBool true, None)];
-               post_command = [(OASISExpr.EBool true, None)];
+               post_command = [(OASISExpr.EBool true, None)]
                };
-          build_type = (`Build, "ocamlbuild", Some "0.3");
+          build_type = (`Build, "ocamlbuild", Some "0.4");
           build_custom =
             {
                pre_command = [(OASISExpr.EBool true, None)];
-               post_command = [(OASISExpr.EBool true, None)];
+               post_command = [(OASISExpr.EBool true, None)]
                };
           install_type = (`Install, "Custom", Some "0.2");
           install_custom =
             {
                pre_command = [(OASISExpr.EBool true, None)];
-               post_command = [(OASISExpr.EBool true, None)];
+               post_command = [(OASISExpr.EBool true, None)]
                };
           uninstall_custom =
             {
                pre_command = [(OASISExpr.EBool true, None)];
-               post_command = [(OASISExpr.EBool true, None)];
+               post_command = [(OASISExpr.EBool true, None)]
                };
           clean_custom =
             {
                pre_command = [(OASISExpr.EBool true, None)];
-               post_command = [(OASISExpr.EBool true, None)];
+               post_command = [(OASISExpr.EBool true, None)]
                };
           distclean_custom =
             {
                pre_command = [(OASISExpr.EBool true, None)];
-               post_command = [(OASISExpr.EBool true, None)];
+               post_command = [(OASISExpr.EBool true, None)]
                };
           files_ab = [];
           sections =
@@ -5827,7 +7222,7 @@
                  ({
                      cs_name = "ospec";
                      cs_data = PropList.Data.create ();
-                     cs_plugin_data = [];
+                     cs_plugin_data = []
                      },
                    {
                       bs_build = [(OASISExpr.EBool true, true)];
@@ -5843,7 +7238,7 @@
                       bs_dlllib = [(OASISExpr.EBool true, [])];
                       bs_dllpath = [(OASISExpr.EBool true, [])];
                       bs_byteopt = [(OASISExpr.EBool true, [])];
-                      bs_nativeopt = [(OASISExpr.EBool true, [])];
+                      bs_nativeopt = [(OASISExpr.EBool true, [])]
                       },
                    {
                       lib_modules =
@@ -5859,13 +7254,13 @@
                       lib_internal_modules = [];
                       lib_findlib_parent = None;
                       lib_findlib_name = None;
-                      lib_findlib_containers = [];
+                      lib_findlib_containers = []
                       });
                Executable
                  ({
                      cs_name = "ospec";
                      cs_data = PropList.Data.create ();
-                     cs_plugin_data = [];
+                     cs_plugin_data = []
                      },
                    {
                       bs_build = [(OASISExpr.EBool true, true)];
@@ -5881,25 +7276,25 @@
                       bs_dlllib = [(OASISExpr.EBool true, [])];
                       bs_dllpath = [(OASISExpr.EBool true, [])];
                       bs_byteopt = [(OASISExpr.EBool true, [])];
-                      bs_nativeopt = [(OASISExpr.EBool true, [])];
+                      bs_nativeopt = [(OASISExpr.EBool true, [])]
                       },
-                   {exec_custom = false; exec_main_is = "ospec.ml"; })
+                   {exec_custom = false; exec_main_is = "ospec.ml"})
             ];
           plugins = [];
           schema_data = PropList.Data.create ();
-          plugin_data = [];
+          plugin_data = []
           };
      oasis_fn = Some "_oasis";
-     oasis_version = "0.3.0";
+     oasis_version = "0.4.1";
      oasis_digest =
        Some "\137\251\225W\225\247\012\164\131q\156\159 \023*\139";
      oasis_exec = None;
      oasis_setup_args = [];
-     setup_update = false;
+     setup_update = false
      };;
 
 let setup () = BaseSetup.setup setup_t;;
 
-# 5904 "setup.ml"
+# 7299 "setup.ml"
 (* OASIS_STOP *)
 let () = setup ();;
